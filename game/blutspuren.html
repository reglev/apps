<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flucht im Dunkeln</title>
    <style>
        * { margin: 0; padding: 0; }
        body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 15px; left: 15px;
            color: #ff3333; font-size: 18px;
            text-shadow: 0 0 10px #ff0000;
            pointer-events: none; z-index: 10;
        }
        #timer {
            position: absolute; top: 15px; right: 15px;
            color: #888; font-size: 16px;
            pointer-events: none; z-index: 10;
        }
        #message {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000; font-size: 36px; text-align: center;
            text-shadow: 0 0 30px currentColor;
            display: none; pointer-events: none; z-index: 20;
            transition: opacity 0.5s;
        }
        #toast {
            position: absolute; top: 75px; left: 50%;
            transform: translateX(-50%);
            color: #ff6600; font-size: 20px; text-align: center;
            text-shadow: 0 0 15px currentColor;
            opacity: 0; pointer-events: none; z-index: 15;
            transition: opacity 0.3s;
        }
        #instructions {
            position: absolute; bottom: 15px; left: 15px;
            color: #555; font-size: 13px;
            pointer-events: none; z-index: 10;
        }
        #startscreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 50;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            color: #ff3333; text-align: center;
        }
        #startscreen h1 {
            font-size: 48px; text-shadow: 0 0 40px #ff0000;
            margin-bottom: 20px; animation: flicker 3s infinite;
        }
        #startscreen p { color: #888; font-size: 16px; margin: 8px 0; max-width: 500px; }
        #startscreen .start-btn {
            margin-top: 30px; padding: 15px 40px;
            background: none; border: 2px solid #ff3333;
            color: #ff3333; font-family: inherit; font-size: 20px;
            cursor: pointer; transition: all 0.3s;
        }
        #startscreen .start-btn:hover {
            background: #ff3333; color: #000;
            box-shadow: 0 0 30px #ff0000;
        }
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            92% { opacity: 1; }
            93% { opacity: 0.3; }
        }

        /* JUMPSCARE overlay - Gefallener Engel */
        #jumpscare {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999; display: none;
            align-items: center; justify-content: center;
            flex-direction: column;
            overflow: hidden;
        }
        #jumpscare.active { display: flex; }
        #jumpscare .scare-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #jumpscare .angel-face {
            position: relative;
            width: 40vmin;
            height: 50vmin;
            animation: faceShake 0.08s infinite;
        }
        #jumpscare .skull {
            position: absolute;
            width: 100%;
            height: 80%;
            background: radial-gradient(ellipse at center, #1a0a0a 0%, #0a0000 60%, #000 100%);
            border-radius: 45% 45% 35% 35%;
            box-shadow: 0 0 80px #ff0000, 0 0 120px #880000, inset 0 0 60px rgba(255,0,0,0.3);
        }
        #jumpscare .eye {
            position: absolute;
            width: 28%;
            height: 25%;
            top: 25%;
            background: #000;
            border-radius: 50% 50% 45% 45%;
            box-shadow: 0 0 40px #ff0000, 0 0 80px #ff0000, inset 0 0 20px #ff3300;
            animation: eyeFlicker 0.15s infinite;
        }
        #jumpscare .eye.left { left: 12%; }
        #jumpscare .eye.right { right: 12%; }
        #jumpscare .eye::after {
            content: '';
            position: absolute;
            width: 40%;
            height: 50%;
            top: 25%;
            left: 30%;
            background: radial-gradient(circle, #ffffff 0%, #ff0000 40%, #ff0000 60%, transparent 100%);
            border-radius: 50%;
            animation: pupilPulse 0.1s infinite;
        }
        #jumpscare .mouth {
            position: absolute;
            width: 50%;
            height: 20%;
            bottom: 15%;
            left: 25%;
            background: #000;
            border-radius: 10% 10% 45% 45%;
            box-shadow: 0 0 30px #880000, inset 0 -10px 20px #220000;
            overflow: hidden;
        }
        #jumpscare .mouth::before {
            content: '';
            position: absolute;
            top: 0;
            left: 5%;
            width: 90%;
            height: 30%;
            background: repeating-linear-gradient(90deg,
                transparent 0%, transparent 8%,
                #442222 8%, #553333 12%,
                transparent 12%, transparent 20%
            );
        }
        #jumpscare .broken-halo {
            position: absolute;
            top: -8%;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 15%;
            border: 4px solid #880000;
            border-radius: 50%;
            border-bottom: none;
            box-shadow: 0 0 20px #ff0000, 0 0 40px #880000;
            animation: haloFlicker 0.2s infinite;
            clip-path: polygon(0 0, 45% 0, 40% 100%, 0 100%, 0 0, 60% 100%, 55% 0, 100% 0, 100% 100%, 60% 100%);
        }
        #jumpscare .crack {
            position: absolute;
            width: 3px;
            background: linear-gradient(to bottom, #ff0000, #880000, transparent);
            box-shadow: 0 0 8px #ff0000;
            animation: crackGlow 0.3s infinite alternate;
        }
        #jumpscare .crack.c1 { height: 40%; top: 20%; left: 35%; transform: rotate(-15deg); }
        #jumpscare .crack.c2 { height: 30%; top: 30%; right: 30%; transform: rotate(10deg); }
        #jumpscare .crack.c3 { height: 25%; top: 45%; left: 45%; transform: rotate(5deg); }
        #jumpscare .blood-tear {
            position: absolute;
            width: 8px;
            height: 30%;
            top: 45%;
            background: linear-gradient(to bottom, #ff0000, #880000, transparent);
            border-radius: 0 0 50% 50%;
            animation: tearDrip 0.8s infinite;
        }
        #jumpscare .blood-tear.left { left: 22%; }
        #jumpscare .blood-tear.right { right: 22%; }
        #jumpscare .death-text {
            position: absolute;
            bottom: 10%;
            font-size: 5vmin;
            color: #880000;
            text-shadow: 0 0 20px #ff0000, 0 0 40px #880000;
            letter-spacing: 8px;
            animation: textReveal 0.5s ease-out;
        }
        @keyframes faceShake {
            0% { transform: translate(-2px, 1px) rotate(-1deg); }
            25% { transform: translate(2px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, -2px) rotate(-0.5deg); }
            75% { transform: translate(1px, 2px) rotate(0.5deg); }
            100% { transform: translate(-2px, 1px) rotate(-1deg); }
        }
        @keyframes eyeFlicker {
            0%, 100% { box-shadow: 0 0 40px #ff0000, 0 0 80px #ff0000, inset 0 0 20px #ff3300; }
            50% { box-shadow: 0 0 60px #ff0000, 0 0 120px #ff3300, inset 0 0 40px #ff6600; }
        }
        @keyframes pupilPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }
        @keyframes haloFlicker {
            0%, 100% { opacity: 1; border-color: #880000; }
            30% { opacity: 0.3; border-color: #ff0000; }
            60% { opacity: 0.8; border-color: #660000; }
        }
        @keyframes crackGlow {
            0% { box-shadow: 0 0 5px #ff0000; }
            100% { box-shadow: 0 0 15px #ff0000, 0 0 25px #880000; }
        }
        @keyframes tearDrip {
            0% { height: 20%; opacity: 0.8; }
            50% { height: 35%; opacity: 1; }
            100% { height: 20%; opacity: 0.6; }
        }
        @keyframes textReveal {
            0% { opacity: 0; letter-spacing: 30px; }
            100% { opacity: 1; letter-spacing: 8px; }
        }

        /* EPILEPSY WARNING */
        .epilepsy-warning {
            color: #ff6600; font-size: 12px; margin-top: 20px;
            padding: 8px 16px; border: 1px solid #ff660044;
            background: rgba(255, 102, 0, 0.05); max-width: 400px;
        }

        /* VICTORY overlay */
        #victory {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999; display: none;
            align-items: center; justify-content: center;
            flex-direction: column; overflow: hidden;
        }
        #victory.active { display: flex; }
        #victory .victory-container {
            position: relative; width: 100vw; height: 100vh;
            display: flex; align-items: center; justify-content: center;
            flex-direction: column;
        }
        #victory .restored-halo {
            width: 25vmin; height: 25vmin;
            border: 4px solid #ffdd44;
            border-radius: 50%;
            box-shadow: 0 0 40px #ffdd44, 0 0 80px #ffaa00, 0 0 120px #ff880044, inset 0 0 30px #ffdd4444;
            animation: haloRestore 1.5s ease-out forwards, haloPulse 2s 1.5s infinite;
            opacity: 0;
        }
        #victory .light-rays {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 120vmax; height: 120vmax; opacity: 0;
            animation: raysAppear 2s 0.5s ease-out forwards;
            background: conic-gradient(
                from 0deg,
                transparent 0deg, rgba(255,220,100,0.15) 5deg, transparent 10deg,
                transparent 30deg, rgba(255,220,100,0.1) 35deg, transparent 40deg,
                transparent 60deg, rgba(255,220,100,0.12) 65deg, transparent 70deg,
                transparent 90deg, rgba(255,220,100,0.08) 95deg, transparent 100deg,
                transparent 120deg, rgba(255,220,100,0.15) 125deg, transparent 130deg,
                transparent 150deg, rgba(255,220,100,0.1) 155deg, transparent 160deg,
                transparent 180deg, rgba(255,220,100,0.12) 185deg, transparent 190deg,
                transparent 210deg, rgba(255,220,100,0.08) 215deg, transparent 220deg,
                transparent 240deg, rgba(255,220,100,0.15) 245deg, transparent 250deg,
                transparent 270deg, rgba(255,220,100,0.1) 275deg, transparent 280deg,
                transparent 300deg, rgba(255,220,100,0.12) 305deg, transparent 310deg,
                transparent 340deg, rgba(255,220,100,0.08) 345deg, transparent 350deg
            );
            animation: raysAppear 2s 0.5s ease-out forwards, raysSpin 20s 0.5s linear infinite;
        }
        #victory .victory-text {
            position: absolute; top: 62%;
            font-size: 5vmin; color: #ffdd44;
            text-shadow: 0 0 20px #ffaa00, 0 0 40px #ff880088;
            letter-spacing: 12px; opacity: 0;
            animation: victoryTextReveal 1s 1s ease-out forwards;
        }
        #victory .victory-stats {
            position: absolute; top: 72%;
            font-size: 2.2vmin; color: #ccaa44;
            text-shadow: 0 0 10px #ffaa0066;
            text-align: center; line-height: 2;
            opacity: 0;
            animation: victoryTextReveal 0.8s 2s ease-out forwards;
        }
        #victory .victory-restart {
            position: absolute; bottom: 8%;
            font-size: 2vmin; color: #887733;
            opacity: 0;
            animation: victoryTextReveal 0.5s 3s ease-out forwards;
        }
        @keyframes haloRestore {
            0% { opacity: 0; transform: scale(0.1) rotate(-180deg); border-color: #880000; box-shadow: 0 0 40px #ff0000; }
            50% { opacity: 0.8; border-color: #ff8800; }
            100% { opacity: 1; transform: scale(1) rotate(0deg); border-color: #ffdd44; box-shadow: 0 0 40px #ffdd44, 0 0 80px #ffaa00, 0 0 120px #ff880044, inset 0 0 30px #ffdd4444; }
        }
        @keyframes haloPulse {
            0%, 100% { box-shadow: 0 0 40px #ffdd44, 0 0 80px #ffaa00, 0 0 120px #ff880044; }
            50% { box-shadow: 0 0 60px #ffee66, 0 0 100px #ffbb22, 0 0 160px #ffaa0066; }
        }
        @keyframes raysAppear {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.3); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        @keyframes raysSpin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
        @keyframes victoryTextReveal {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div id="startscreen">
        <h1>&#x1F526; FLUCHT IM DUNKELN</h1>
        <p style="color:#aaa; font-style:italic;">Ein Engel ist gefallen.</p>
        <p>Einst ein W&auml;chter des Himmels &mdash; jetzt wandert er durch die Dunkelheit, getrieben von unstillbarem <span style="color:#ff0000">Blutdurst</span>.</p>
        <p>Er jagt Menschen. Aber er ist... <span style="color:#ff4444">fair</span>.</p>
        <p style="color:#aaa;">Jetzt ist er bekannt als der <span style="color:#ff0000; font-size:20px; text-shadow: 0 0 15px #ff0000;">CELESTIAL</span>.</p>
        <p style="color:#ccc; margin-top:10px;">Sammle f&uuml;r ihn alle Blutspuren, w&auml;hrend er dich jagt &mdash; und er l&auml;sst dich am Leben.</p>
        <p style="color:#ff6600; margin-top:15px;">&#x26A0;&#xFE0F; Vorsicht: Manche Spuren sind <span style="color:#00cc00">FAKE</span>! Sie kosten dich Punkte.</p>
        <p style="color:#555; margin-top:15px; font-size:13px;">
            WASD / Pfeiltasten = Bewegen<br>
            R = Neustart
        </p>
        <div class="epilepsy-warning">&#x26A0;&#xFE0F; EPILEPSIE-WARNUNG: Dieses Spiel enth&auml;lt schnelle Lichtblitze, Flackereffekte und pl&ouml;tzliche visuelle Reize, die bei empfindlichen Personen epileptische Anf&auml;lle ausl&ouml;sen k&ouml;nnen.</div>
        <button class="start-btn" id="startBtn">&#x25B6; SPIELEN</button>
    </div>
    <div id="ui">Spuren: <span id="score">0</span> / <span id="total">0</span> | Verbleibend: <span id="remaining">0</span></div>
    <div id="timer">Zeit: 0s</div>
    <div id="message"></div>
    <div id="toast"></div>
    <div id="instructions">WASD / Pfeile &bull; R = Neustart</div>
    <div id="jumpscare">
        <div class="scare-container">
            <div class="angel-face">
                <div class="skull">
                    <div class="broken-halo"></div>
                    <div class="eye left"></div>
                    <div class="eye right"></div>
                    <div class="mouth"></div>
                    <div class="crack c1"></div>
                    <div class="crack c2"></div>
                    <div class="crack c3"></div>
                    <div class="blood-tear left"></div>
                    <div class="blood-tear right"></div>
                </div>
            </div>
            <div class="death-text">ER HAT DICH GEFUNDEN</div>
        </div>
    </div>
    <div id="victory">
        <div class="victory-container">
            <div class="light-rays"></div>
            <div class="restored-halo"></div>
            <div class="victory-text">DU BIST ENTKOMMEN</div>
            <div class="victory-stats" id="victoryStats"></div>
            <div class="victory-restart">R = Neustart</div>
        </div>
    </div>
    <canvas id="game"></canvas>

    <script>
    // ════════════════════════════════════════
    // 1. CONSTANTS
    // ════════════════════════════════════════
    const FLASH_RADIUS = 260;
    const HALF_CONE = Math.PI / 3.8;
    const TELEPORT_COOLDOWN = 8000;
    const LIGHTS_OUT_INTERVAL = 13000;
    const LIGHTS_OUT_FLICKER = 3000;
    const LIGHTS_OUT_DARK = 2000;
    const DARK_PULSE_INTERVAL = 20000;
    const DARK_PULSE_DURATION = 4000;
    const PLAYER_RADIUS = 11;
    const CATCH_DISTANCE = 28;
    const COLLECT_DISTANCE = 35;
    const PROXIMITY_DISTANCE = 200;
    const SPAWN_MIN_DISTANCE = 400;
    const TRACK_SPAWN_MIN_DISTANCE = 180;
    const FAKE_TRACK_SPAWN_MIN_DISTANCE = 150;
    const TWO_PI = Math.PI * 2;

    // ════════════════════════════════════════
    // 2. GameState
    // ════════════════════════════════════════
    class GameState {
        constructor() {
            this.player = { x: 0, y: 0, speed: 3.2, angle: 0 };
            this.tracks = [];
            this.monster = { x: 0, y: 0, speed: 0.7 };
            this.particles = [];
            this.shakeX = 0;
            this.shakeY = 0;
            this.shakeDur = 0;
            this.shakeIntensity = 0;
            this.teleportTimer = 0;
            this.teleportCooldown = TELEPORT_COOLDOWN;
            this.teleportFlash = 0;
            this.lightsOutTimer = 0;
            this.lightsOutPhase = 'none';
            this.lightsOutStart = 0;
            this.darkPulseTimer = 0;
            this.darkPulseActive = false;
            this.startTime = 0;
            this.found = 0;
            this.total = 0;
            this.gameOver = false;
            this.won = false;
            this.started = false;
            this.flashRadius = FLASH_RADIUS;
            this.flashCone = HALF_CONE * 2;
            this.toastTimer = 0;
            this.gate = { x: 0, y: 0, active: false, radius: 60 };
            this.victoryTime = 0;
            this.victoryActive = false;
            this.minMonsterDist = Infinity;
        }

        reset(canvasW, canvasH) {
            this.found = 0;
            this.gameOver = false;
            this.won = false;
            this.particles = [];
            this.shakeDur = 0;
            this.shakeIntensity = 0;
            this.toastTimer = 0;

            const now = Date.now();
            this.teleportTimer = now;
            this.teleportFlash = 0;
            this.lightsOutTimer = now;
            this.lightsOutPhase = 'none';
            this.darkPulseTimer = now;
            this.darkPulseActive = false;
            this.startTime = now;
            this.flashRadius = FLASH_RADIUS;

            this.gate.active = false;
            this.gate.x = 0;
            this.gate.y = 0;
            this.victoryTime = 0;
            this.victoryActive = false;
            this.minMonsterDist = Infinity;

            this.player.x = canvasW / 2;
            this.player.y = canvasH / 2;
            this.player.angle = 0;
        }
    }

    // ════════════════════════════════════════
    // 3. AudioManager
    // ════════════════════════════════════════
    class AudioManager {
        constructor() {
            this.ctx = null;
            this.masterGain = null;
            this.organGain = null;
            this.heartGain = null;
            this.whisperGain = null;
            this.jumpscareGain = null;
            this.victoryGain = null;
            this.started = false;
        }

        init() {
            if (this.started) return;
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();

            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.8;
            this.masterGain.connect(this.ctx.destination);

            this.organGain = this.ctx.createGain();
            this.organGain.gain.value = 0.2;
            this.organGain.connect(this.masterGain);

            this.heartGain = this.ctx.createGain();
            this.heartGain.gain.value = 0;
            this.heartGain.connect(this.masterGain);

            this.whisperGain = this.ctx.createGain();
            this.whisperGain.gain.value = 0;
            this.whisperGain.connect(this.masterGain);

            this.jumpscareGain = this.ctx.createGain();
            this.jumpscareGain.gain.value = 1.0;
            this.jumpscareGain.connect(this.ctx.destination);

            this.victoryGain = this.ctx.createGain();
            this.victoryGain.gain.value = 1.0;
            this.victoryGain.connect(this.ctx.destination);

            this.started = true;
        }

        get currentTime() {
            return this.ctx ? this.ctx.currentTime : 0;
        }

        get sampleRate() {
            return this.ctx ? this.ctx.sampleRate : 44100;
        }

        createOscillator() { return this.ctx.createOscillator(); }
        createGain() { return this.ctx.createGain(); }
        createBiquadFilter() { return this.ctx.createBiquadFilter(); }
        createBuffer(channels, length, rate) { return this.ctx.createBuffer(channels, length, rate); }
        createBufferSource() { return this.ctx.createBufferSource(); }
        createStereoPanner() { return this.ctx.createStereoPanner(); }
    }

    // ════════════════════════════════════════
    // 4. OrganSound
    // ════════════════════════════════════════
    class OrganSound {
        constructor(audio) {
            this.audio = audio;
            this.timeout = null;
            this.notes = [55, 58.27, 65.41, 73.42, 82.41, 87.31, 98, 110];
        }

        playNote(freq, dur) {
            if (!this.audio.ctx) return;
            const now = this.audio.currentTime;
            const osc = this.audio.createOscillator();
            const gain = this.audio.createGain();
            const filter = this.audio.createBiquadFilter();
            osc.type = 'sawtooth';
            osc.frequency.value = freq;
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            filter.Q.value = 2;
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.3, now + 0.3);
            gain.gain.linearRampToValueAtTime(0.15, now + dur * 0.6);
            gain.gain.exponentialRampToValueAtTime(0.001, now + dur);
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(this.audio.organGain);
            osc.start(); osc.stop(now + dur);

            const osc2 = this.audio.createOscillator();
            const gain2 = this.audio.createGain();
            osc2.type = 'sine'; osc2.frequency.value = freq * 1.5;
            gain2.gain.setValueAtTime(0, now);
            gain2.gain.linearRampToValueAtTime(0.1, now + 0.5);
            gain2.gain.exponentialRampToValueAtTime(0.001, now + dur);
            osc2.connect(gain2); gain2.connect(this.audio.organGain);
            osc2.start(); osc2.stop(now + dur);
        }

        start(state) {
            if (this.timeout) return;
            const next = () => {
                if (!state.started || state.gameOver) return;
                this.playNote(this.notes[Math.floor(Math.random() * this.notes.length)], 2 + Math.random() * 4);
                this.timeout = setTimeout(next, 2000 + Math.random() * 3000);
            };
            next();
        }

        stop() {
            if (this.timeout) { clearTimeout(this.timeout); this.timeout = null; }
        }
    }

    // ════════════════════════════════════════
    // 5. HeartbeatSound
    // ════════════════════════════════════════
    class HeartbeatSound {
        constructor(audio) {
            this.audio = audio;
            this.interval = null;
            this.active = false;
        }

        play() {
            if (!this.audio.ctx) return;
            const now = this.audio.currentTime;
            const o1 = this.audio.createOscillator(), g1 = this.audio.createGain();
            o1.type = 'sine';
            o1.frequency.setValueAtTime(65, now);
            o1.frequency.exponentialRampToValueAtTime(30, now + 0.15);
            g1.gain.setValueAtTime(1.0, now);
            g1.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
            o1.connect(g1); g1.connect(this.audio.heartGain);
            o1.start(now); o1.stop(now + 0.3);

            const o2 = this.audio.createOscillator(), g2 = this.audio.createGain();
            o2.type = 'sine';
            o2.frequency.setValueAtTime(55, now + 0.12);
            o2.frequency.exponentialRampToValueAtTime(25, now + 0.35);
            g2.gain.setValueAtTime(0, now);
            g2.gain.setValueAtTime(0.8, now + 0.12);
            g2.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
            o2.connect(g2); g2.connect(this.audio.heartGain);
            o2.start(now); o2.stop(now + 0.4);
        }

        updateProximity(distance) {
            if (!this.audio.ctx || !this.audio.heartGain) return;
            if (distance < PROXIMITY_DISTANCE) {
                const intensity = (1 - distance / 200) * 1.5;
                this.audio.heartGain.gain.linearRampToValueAtTime(intensity, this.audio.currentTime + 0.1);
                if (!this.active) {
                    this.active = true;
                    this.interval = setInterval(() => this.play(), 700);
                    this.play();
                }
            } else {
                if (this.active) {
                    this.active = false;
                    this.audio.heartGain.gain.linearRampToValueAtTime(0, this.audio.currentTime + 0.3);
                    if (this.interval) { clearInterval(this.interval); this.interval = null; }
                }
            }
        }

        stop() {
            this.active = false;
            if (this.interval) { clearInterval(this.interval); this.interval = null; }
            if (this.audio.heartGain) {
                this.audio.heartGain.gain.linearRampToValueAtTime(0, this.audio.currentTime + 0.1);
            }
        }
    }

    // ════════════════════════════════════════
    // 6. WhisperSound
    // ════════════════════════════════════════
    class WhisperSound {
        constructor(audio) {
            this.audio = audio;
            this.interval = null;
        }

        play() {
            if (!this.audio.ctx) return;
            const now = this.audio.currentTime;
            const dur = 0.5 + Math.random() * 1.5;

            const bufSize = this.audio.sampleRate * dur;
            const buf = this.audio.createBuffer(1, bufSize, this.audio.sampleRate);
            const data = buf.getChannelData(0);
            for (let i = 0; i < bufSize; i++) {
                const env = Math.sin(i / bufSize * Math.PI);
                const tremolo = 0.5 + 0.5 * Math.sin(i / this.audio.sampleRate * (8 + Math.random() * 15) * Math.PI * 2);
                data[i] = (Math.random() * 2 - 1) * env * tremolo;
            }
            const src = this.audio.createBufferSource();
            src.buffer = buf;

            const bp = this.audio.createBiquadFilter();
            bp.type = 'bandpass';
            bp.frequency.value = 300 + Math.random() * 600;
            bp.Q.value = 5 + Math.random() * 10;

            const bp2 = this.audio.createBiquadFilter();
            bp2.type = 'bandpass';
            bp2.frequency.value = 1500 + Math.random() * 1500;
            bp2.Q.value = 3;

            const gain = this.audio.createGain();
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.4, now + 0.1);
            gain.gain.setValueAtTime(0.3, now + dur * 0.5);
            gain.gain.exponentialRampToValueAtTime(0.001, now + dur);

            const pan = this.audio.createStereoPanner();
            pan.pan.value = (Math.random() - 0.5) * 1.8;

            src.connect(bp);
            bp.connect(bp2);
            bp2.connect(gain);
            gain.connect(pan);
            pan.connect(this.audio.whisperGain);
            src.start(now); src.stop(now + dur);

            if (Math.random() < 0.3) {
                const moan = this.audio.createOscillator();
                const moanGain = this.audio.createGain();
                moan.type = 'sawtooth';
                moan.frequency.setValueAtTime(80 + Math.random() * 40, now);
                moan.frequency.linearRampToValueAtTime(60 + Math.random() * 30, now + dur);
                const moanFilter = this.audio.createBiquadFilter();
                moanFilter.type = 'lowpass'; moanFilter.frequency.value = 200;
                moanGain.gain.setValueAtTime(0, now);
                moanGain.gain.linearRampToValueAtTime(0.15, now + 0.2);
                moanGain.gain.exponentialRampToValueAtTime(0.001, now + dur);
                moan.connect(moanFilter); moanFilter.connect(moanGain); moanGain.connect(this.audio.whisperGain);
                moan.start(now); moan.stop(now + dur);
            }
        }

        start() {
            if (this.interval) return;
            if (this.audio.whisperGain) {
                this.audio.whisperGain.gain.linearRampToValueAtTime(0.5, this.audio.currentTime + 0.3);
            }
            this.play();
            this.interval = setInterval(() => this.play(), 400 + Math.random() * 600);
        }

        stop() {
            if (this.interval) { clearInterval(this.interval); this.interval = null; }
            if (this.audio.whisperGain) {
                this.audio.whisperGain.gain.linearRampToValueAtTime(0, this.audio.currentTime + 0.5);
            }
        }
    }

    // ════════════════════════════════════════
    // 7. SFX
    // ════════════════════════════════════════
    const SFX = {
        audio: null,

        init(audio) { this.audio = audio; },

        bloodCollect() {
            if (!this.audio.ctx) return;
            const now = this.audio.currentTime;

            const bubble = this.audio.createOscillator();
            const bubbleGain = this.audio.createGain();
            const bubbleFilter = this.audio.createBiquadFilter();
            bubble.type = 'sine';
            bubble.frequency.setValueAtTime(180, now);
            bubble.frequency.exponentialRampToValueAtTime(80, now + 0.3);
            bubbleFilter.type = 'lowpass';
            bubbleFilter.frequency.value = 400;
            bubbleGain.gain.setValueAtTime(0.4, now);
            bubbleGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
            bubble.connect(bubbleFilter);
            bubbleFilter.connect(bubbleGain);
            bubbleGain.connect(this.audio.masterGain);
            bubble.start(now); bubble.stop(now + 0.35);

            const hiss = this.audio.createOscillator();
            const hissGain = this.audio.createGain();
            hiss.type = 'sawtooth';
            hiss.frequency.setValueAtTime(2000, now);
            hiss.frequency.exponentialRampToValueAtTime(500, now + 0.15);
            hissGain.gain.setValueAtTime(0.15, now);
            hissGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            hiss.connect(hissGain);
            hissGain.connect(this.audio.masterGain);
            hiss.start(now); hiss.stop(now + 0.2);

            const hum = this.audio.createOscillator();
            const humGain = this.audio.createGain();
            hum.type = 'sine';
            hum.frequency.value = 110;
            humGain.gain.setValueAtTime(0, now);
            humGain.gain.linearRampToValueAtTime(0.3, now + 0.1);
            humGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
            hum.connect(humGain);
            humGain.connect(this.audio.masterGain);
            hum.start(now); hum.stop(now + 0.55);
        },

        fakeCollect() {
            if (!this.audio.ctx) return;
            const now = this.audio.currentTime;

            const wrong = this.audio.createOscillator();
            const wrongGain = this.audio.createGain();
            wrong.type = 'square';
            wrong.frequency.setValueAtTime(300, now);
            wrong.frequency.setValueAtTime(280, now + 0.1);
            wrong.frequency.setValueAtTime(310, now + 0.2);
            wrong.frequency.setValueAtTime(260, now + 0.3);
            wrongGain.gain.setValueAtTime(0.3, now);
            wrongGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
            wrong.connect(wrongGain);
            wrongGain.connect(this.audio.masterGain);
            wrong.start(now); wrong.stop(now + 0.45);

            const warn = this.audio.createOscillator();
            const warnGain = this.audio.createGain();
            warn.type = 'sine';
            warn.frequency.setValueAtTime(1500, now);
            warn.frequency.linearRampToValueAtTime(2000, now + 0.15);
            warnGain.gain.setValueAtTime(0.2, now);
            warnGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            warn.connect(warnGain);
            warnGain.connect(this.audio.masterGain);
            warn.start(now); warn.stop(now + 0.2);

            const growl = this.audio.createOscillator();
            const growlGain = this.audio.createGain();
            growl.type = 'sawtooth';
            growl.frequency.setValueAtTime(100, now);
            growl.frequency.linearRampToValueAtTime(60, now + 0.3);
            const growlFilter = this.audio.createBiquadFilter();
            growlFilter.type = 'lowpass';
            growlFilter.frequency.value = 200;
            growlGain.gain.setValueAtTime(0.25, now);
            growlGain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
            growl.connect(growlFilter);
            growlFilter.connect(growlGain);
            growlGain.connect(this.audio.masterGain);
            growl.start(now); growl.stop(now + 0.4);
        },

        gateAppears() {
            if (!this.audio.ctx) return;
            const now = this.audio.currentTime;

            const gateOsc = this.audio.createOscillator();
            const gateGain = this.audio.createGain();
            gateOsc.type = 'sine';
            gateOsc.frequency.setValueAtTime(220, now);
            gateOsc.frequency.exponentialRampToValueAtTime(880, now + 1.5);
            gateGain.gain.setValueAtTime(0, now);
            gateGain.gain.linearRampToValueAtTime(0.5, now + 0.3);
            gateGain.gain.exponentialRampToValueAtTime(0.001, now + 2);

            const gateFilter = this.audio.createBiquadFilter();
            gateFilter.type = 'lowpass';
            gateFilter.frequency.value = 1200;

            gateOsc.connect(gateFilter);
            gateFilter.connect(gateGain);
            gateGain.connect(this.audio.masterGain);
            gateOsc.start(now); gateOsc.stop(now + 2.1);

            for (let i = 0; i < 3; i++) {
                const bell = this.audio.createOscillator();
                const bellGain = this.audio.createGain();
                bell.type = 'sine';
                bell.frequency.value = 660 * (i + 1);
                bellGain.gain.setValueAtTime(0, now + i * 0.1);
                bellGain.gain.linearRampToValueAtTime(0.2, now + i * 0.1 + 0.05);
                bellGain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.1 + 1);
                bell.connect(bellGain);
                bellGain.connect(this.audio.masterGain);
                bell.start(now + i * 0.1); bell.stop(now + i * 0.1 + 1.1);
            }
        }
    };

    // ════════════════════════════════════════
    // 8. JumpscareSystem
    // ════════════════════════════════════════
    class JumpscareSystem {
        constructor(audio) {
            this.audio = audio;
        }

        trigger() {
            this.showVisual();
            this.playAudio();
        }

        showVisual() {
            const jumpEl = document.getElementById('jumpscare');
            jumpEl.style.display = 'flex';
            jumpEl.classList.add('active');
            document.body.style.overflow = 'hidden';

            let flashes = 0;
            const flashInterval = setInterval(() => {
                const phase = flashes % 5;
                if (phase === 0) jumpEl.style.background = '#200000';
                else if (phase === 1) jumpEl.style.background = '#000';
                else if (phase === 2) jumpEl.style.background = '#ff0000';
                else if (phase === 3) jumpEl.style.background = '#000';
                else jumpEl.style.background = '#100000';
                flashes++;
                if (flashes > 15) {
                    clearInterval(flashInterval);
                    jumpEl.style.background = '#000';
                }
            }, 80);

            setTimeout(() => {
                jumpEl.style.transition = 'opacity 0.5s';
                jumpEl.style.opacity = '0';
                setTimeout(() => {
                    jumpEl.classList.remove('active');
                    jumpEl.style.display = 'none';
                    jumpEl.style.opacity = '1';
                    jumpEl.style.transition = '';
                }, 500);
                document.body.style.overflow = '';
            }, 2500);
        }

        playAudio() {
            if (!this.audio.ctx) return;
            const now = this.audio.currentTime;

            const choirFreqs = [220, 277, 330, 440, 554, 659];
            const fallenFreqs = [110, 116.5, 130.8, 138.6, 155.6, 164.8];
            choirFreqs.forEach((freq, idx) => {
                const osc = this.audio.createOscillator();
                const gain = this.audio.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, now);
                osc.frequency.linearRampToValueAtTime(fallenFreqs[idx], now + 0.5);
                osc.type = 'sawtooth';
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.setValueAtTime(0.5, now + 0.5);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 3);
                osc.connect(gain); gain.connect(this.audio.jumpscareGain);
                osc.start(now); osc.stop(now + 3.1);
            });

            const scream = this.audio.createOscillator();
            const screamGain = this.audio.createGain();
            scream.type = 'sine';
            scream.frequency.setValueAtTime(880, now);
            scream.frequency.exponentialRampToValueAtTime(110, now + 1);
            scream.type = 'sawtooth';
            screamGain.gain.setValueAtTime(0.8, now);
            screamGain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
            scream.connect(screamGain);
            screamGain.connect(this.audio.jumpscareGain);
            scream.start(now); scream.stop(now + 1.6);

            for (let w = 0; w < 3; w++) {
                const bufSize = this.audio.sampleRate * 0.8;
                const buf = this.audio.createBuffer(1, bufSize, this.audio.sampleRate);
                const data = buf.getChannelData(0);
                for (let i = 0; i < bufSize; i++) {
                    const env = Math.exp(-i / (this.audio.sampleRate * 0.3));
                    const flap = Math.sin(i / this.audio.sampleRate * 30 * Math.PI * 2);
                    data[i] = (Math.random() * 2 - 1) * env * (0.3 + flap * 0.7);
                }
                const src = this.audio.createBufferSource();
                src.buffer = buf;
                const wingGain = this.audio.createGain();
                wingGain.gain.value = 0.6;
                src.connect(wingGain);
                wingGain.connect(this.audio.jumpscareGain);
                src.start(now + w * 0.2);
            }

            const bell = this.audio.createOscillator();
            const bellGain = this.audio.createGain();
            bell.type = 'sine';
            bell.frequency.setValueAtTime(880, now);
            bell.frequency.exponentialRampToValueAtTime(55, now + 2);
            bellGain.gain.setValueAtTime(0.5, now);
            bellGain.gain.exponentialRampToValueAtTime(0.001, now + 2.5);
            bell.connect(bellGain);
            bellGain.connect(this.audio.jumpscareGain);
            bell.start(now); bell.stop(now + 2.6);

            const fall = this.audio.createOscillator();
            const fallGain = this.audio.createGain();
            fall.type = 'sine';
            fall.frequency.setValueAtTime(200, now);
            fall.frequency.exponentialRampToValueAtTime(20, now + 1);
            fallGain.gain.setValueAtTime(1.0, now);
            fallGain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
            fall.connect(fallGain);
            fallGain.connect(this.audio.jumpscareGain);
            fall.start(now); fall.stop(now + 1.6);
        }
    }

    // ════════════════════════════════════════
    // 8b. VictorySystem
    // ════════════════════════════════════════
    class VictorySystem {
        constructor(audio) {
            this.audio = audio;
        }

        trigger(state) {
            state.victoryTime = Date.now();
            state.victoryActive = true;
            this.showVisual(state);
            this.playAudio();
        }

        showVisual(state) {
            const secs = Math.floor((Date.now() - state.startTime) / 1000);
            const closest = Math.max(1, Math.floor(state.minMonsterDist));
            const fakes = state.tracks.filter(t => t.isFake && t.found).length;

            // Delay overlay to let canvas effects play first
            setTimeout(() => {
                const el = document.getElementById('victory');
                el.style.display = 'flex';
                el.classList.add('active');
                el.style.background = '#000';

                // Golden flash sequence
                let flashes = 0;
                const flashInterval = setInterval(() => {
                    const phase = flashes % 4;
                    if (phase === 0) el.style.background = '#1a1000';
                    else if (phase === 1) el.style.background = '#000';
                    else if (phase === 2) el.style.background = '#332200';
                    else el.style.background = '#0a0800';
                    flashes++;
                    if (flashes > 8) {
                        clearInterval(flashInterval);
                        el.style.background = '#000';
                    }
                }, 120);

                // Stats
                const statsEl = document.getElementById('victoryStats');
                statsEl.innerHTML =
                    `Zeit: ${secs}s<br>` +
                    `Spuren gesammelt: ${state.found} / ${state.total}<br>` +
                    `Falsche Spuren ber&uuml;hrt: ${fakes}<br>` +
                    `Knappste Begegnung: ${closest}px`;
            }, 1800);
        }

        playAudio() {
            if (!this.audio.ctx) return;
            const now = this.audio.currentTime;
            const vg = this.audio.victoryGain;

            // 1. AUFSTEIGENDER ENGELSCHOR (Gegenteil vom Jumpscare-Fall)
            const choirFreqs = [220, 277, 330, 440, 554, 659, 880];
            choirFreqs.forEach((freq, idx) => {
                const osc = this.audio.createOscillator();
                const gain = this.audio.createGain();
                osc.type = 'sine';
                // Startet tief, steigt auf
                osc.frequency.setValueAtTime(freq * 0.5, now);
                osc.frequency.linearRampToValueAtTime(freq, now + 0.8);
                osc.frequency.linearRampToValueAtTime(freq * 1.2, now + 3);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.2, now + 0.3 + idx * 0.1);
                gain.gain.setValueAtTime(0.25, now + 2);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 5);
                osc.connect(gain); gain.connect(vg);
                osc.start(now + idx * 0.08); osc.stop(now + 5.1);
            });

            // 2. Quinte-Obertöne (himmlisch)
            [330, 440, 554, 660, 880].forEach((freq, idx) => {
                const osc = this.audio.createOscillator();
                const gain = this.audio.createGain();
                osc.type = 'sine';
                osc.frequency.value = freq * 1.5;
                gain.gain.setValueAtTime(0, now + 0.5);
                gain.gain.linearRampToValueAtTime(0.08, now + 1);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 4);
                osc.connect(gain); gain.connect(vg);
                osc.start(now + 0.5 + idx * 0.05); osc.stop(now + 4.1);
            });

            // 3. KASKADIERENDE GLOCKEN (aufsteigend)
            const bellFreqs = [523, 659, 784, 1047, 1319, 1568, 2093];
            bellFreqs.forEach((freq, idx) => {
                const bell = this.audio.createOscillator();
                const bellGain = this.audio.createGain();
                bell.type = 'sine';
                bell.frequency.value = freq;
                const startT = now + 0.3 + idx * 0.15;
                bellGain.gain.setValueAtTime(0, startT);
                bellGain.gain.linearRampToValueAtTime(0.3, startT + 0.02);
                bellGain.gain.exponentialRampToValueAtTime(0.001, startT + 1.5);
                bell.connect(bellGain); bellGain.connect(vg);
                bell.start(startT); bell.stop(startT + 1.6);

                // Oberton pro Glocke
                const ot = this.audio.createOscillator();
                const otg = this.audio.createGain();
                ot.type = 'sine';
                ot.frequency.value = freq * 2.76;
                otg.gain.setValueAtTime(0, startT);
                otg.gain.linearRampToValueAtTime(0.06, startT + 0.01);
                otg.gain.exponentialRampToValueAtTime(0.001, startT + 0.8);
                ot.connect(otg); otg.connect(vg);
                ot.start(startT); ot.stop(startT + 0.9);
            });

            // 4. LICHT-RAUSCHEN (anschwellend)
            const rushDur = 3;
            const rushBuf = this.audio.createBuffer(2, this.audio.sampleRate * rushDur, this.audio.sampleRate);
            for (let ch = 0; ch < 2; ch++) {
                const data = rushBuf.getChannelData(ch);
                for (let i = 0; i < data.length; i++) {
                    const env = Math.sin((i / data.length) * Math.PI);
                    const shimmer = 0.5 + 0.5 * Math.sin(i / this.audio.sampleRate * 20 * Math.PI * 2);
                    data[i] = (Math.random() * 2 - 1) * env * shimmer * 0.3;
                }
            }
            const rushSrc = this.audio.createBufferSource();
            rushSrc.buffer = rushBuf;
            const rushFilter = this.audio.createBiquadFilter();
            rushFilter.type = 'highpass';
            rushFilter.frequency.value = 2000;
            rushFilter.frequency.linearRampToValueAtTime(8000, now + rushDur);
            const rushGain = this.audio.createGain();
            rushGain.gain.setValueAtTime(0, now);
            rushGain.gain.linearRampToValueAtTime(0.4, now + 1);
            rushGain.gain.exponentialRampToValueAtTime(0.001, now + rushDur);
            rushSrc.connect(rushFilter);
            rushFilter.connect(rushGain);
            rushGain.connect(vg);
            rushSrc.start(now); rushSrc.stop(now + rushDur + 0.1);

            // 5. SUB-BASS AUFSTIEG (Gegenteil vom Fall)
            const rise = this.audio.createOscillator();
            const riseGain = this.audio.createGain();
            rise.type = 'sine';
            rise.frequency.setValueAtTime(30, now);
            rise.frequency.exponentialRampToValueAtTime(120, now + 2);
            riseGain.gain.setValueAtTime(0.6, now);
            riseGain.gain.linearRampToValueAtTime(0.8, now + 1);
            riseGain.gain.exponentialRampToValueAtTime(0.001, now + 2.5);
            rise.connect(riseGain); riseGain.connect(vg);
            rise.start(now); rise.stop(now + 2.6);

            // 6. FINALER AKKORD (verzögert, majestätisch)
            setTimeout(() => {
                if (!this.audio.ctx) return;
                const t2 = this.audio.currentTime;
                [261.6, 329.6, 392, 523.3, 659.3].forEach((freq, idx) => {
                    const osc = this.audio.createOscillator();
                    const gain = this.audio.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0, t2);
                    gain.gain.linearRampToValueAtTime(0.2, t2 + 0.1);
                    gain.gain.setValueAtTime(0.15, t2 + 2);
                    gain.gain.exponentialRampToValueAtTime(0.001, t2 + 4);
                    osc.connect(gain); gain.connect(vg);
                    osc.start(t2); osc.stop(t2 + 4.1);
                });
            }, 1800);
        }

        hide() {
            const el = document.getElementById('victory');
            el.classList.remove('active');
            el.style.display = 'none';
        }
    }

    // ════════════════════════════════════════
    // 9. InputManager
    // ════════════════════════════════════════
    class InputManager {
        constructor() {
            this.pressed = {};
        }

        init(onRestart) {
            document.addEventListener('keydown', e => {
                this.pressed[e.key.toLowerCase()] = true;
                if (e.key.toLowerCase() === 'r') onRestart();
            });
            document.addEventListener('keyup', e => { this.pressed[e.key.toLowerCase()] = false; });
        }

        isDown(key) {
            return !!this.pressed[key];
        }
    }

    // ════════════════════════════════════════
    // 10. ParticleSystem
    // ════════════════════════════════════════
    class ParticleSystem {
        constructor(state) {
            this.state = state;
        }

        spawn(x, y, color, count = 8) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * TWO_PI;
                const spd = 1 + Math.random() * 3;
                this.state.particles.push({
                    x, y, vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd,
                    life: 1, decay: 0.02 + Math.random() * 0.03,
                    size: 2 + Math.random() * 4, color
                });
            }
        }

        update() {
            for (let i = this.state.particles.length - 1; i >= 0; i--) {
                const p = this.state.particles[i];
                p.x += p.vx; p.y += p.vy;
                p.life -= p.decay;
                if (p.life <= 0) this.state.particles.splice(i, 1);
            }
        }

        render(ctx) {
            this.state.particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, TWO_PI);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }
    }

    // ════════════════════════════════════════
    // 11. UI
    // ════════════════════════════════════════
    const UI = {
        shake(state, intensity = 5, duration = 200) {
            state.shakeDur = duration;
            state.shakeIntensity = intensity;
        },

        showToast(state, text, color = '#ff6600', duration = 1500) {
            const el = document.getElementById('toast');
            el.innerHTML = text;
            el.style.color = color;
            el.style.textShadow = `0 0 15px ${color}`;
            el.style.opacity = 1;
            state.toastTimer = duration;
        },

        showMessage(text, color = '#ff0000') {
            const el = document.getElementById('message');
            el.innerHTML = text;
            el.style.color = color;
            el.style.textShadow = `0 0 30px ${color}`;
            el.style.display = 'block';
            el.style.opacity = 1;
        },

        updateShake(state, dt) {
            if (state.shakeDur > 0) {
                state.shakeDur -= dt;
                state.shakeX = (Math.random() - 0.5) * state.shakeIntensity * 2;
                state.shakeY = (Math.random() - 0.5) * state.shakeIntensity * 2;
            } else {
                state.shakeX = 0; state.shakeY = 0;
            }
        },

        updateToast(state, dt) {
            if (state.toastTimer > 0) {
                state.toastTimer -= dt;
                if (state.toastTimer <= 0) {
                    document.getElementById('toast').style.opacity = 0;
                }
            }
        },

        updateHUD(state) {
            const elapsed = Math.floor((Date.now() - state.startTime) / 1000);
            document.getElementById('timer').textContent = `Zeit: ${elapsed}s`;
        }
    };

    // ════════════════════════════════════════
    // 12. Spawner
    // ════════════════════════════════════════
    const Spawner = {
        spawnTracks(state, canvasW, canvasH) {
            state.tracks = [];
            const total = 14 + Math.floor(Math.random() * 5);
            let created = 0;

            while (created < total) {
                const cx = 80 + Math.random() * (canvasW - 160);
                const cy = 80 + Math.random() * (canvasH - 160);
                if (Math.hypot(cx - state.player.x, cy - state.player.y) < TRACK_SPAWN_MIN_DISTANCE) continue;

                const cluster = Math.random() < 0.6 ? (Math.random() < 0.5 ? 2 : 3) : 1;
                const actual = Math.min(cluster, total - created);

                for (let i = 0; i < actual; i++) {
                    const angle = Math.random() * TWO_PI;
                    const dist = i === 0 ? 0 : 20 + Math.random() * 35;
                    const sizeMul = [0.6, 1, 1, 1.3][Math.floor(Math.random() * 4)];
                    state.tracks.push({
                        x: cx + Math.cos(angle) * dist,
                        y: cy + Math.sin(angle) * dist,
                        size: (12 + Math.random() * 18) * sizeMul,
                        shade: Math.random(),
                        isFake: false,
                        found: false
                    });
                    created++;
                }
            }
            state.total = created;

            const fakes = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < fakes; i++) {
                let fx, fy;
                do {
                    fx = 60 + Math.random() * (canvasW - 120);
                    fy = 60 + Math.random() * (canvasH - 120);
                } while (Math.hypot(fx - state.player.x, fy - state.player.y) < FAKE_TRACK_SPAWN_MIN_DISTANCE);
                state.tracks.push({
                    x: fx, y: fy,
                    size: 10 + Math.random() * 16,
                    shade: Math.random(),
                    isFake: true,
                    found: false
                });
            }
        },

        spawnMonster(state, canvasW, canvasH) {
            do {
                state.monster.x = Math.random() * canvasW;
                state.monster.y = Math.random() * canvasH;
            } while (Math.hypot(state.monster.x - state.player.x, state.monster.y - state.player.y) < SPAWN_MIN_DISTANCE);
        },

        spawnReplacementTrack(state, canvasW, canvasH) {
            let newX, newY, attempts = 0;
            do {
                newX = 60 + Math.random() * (canvasW - 120);
                newY = 60 + Math.random() * (canvasH - 120);
                attempts++;
            } while (
                (Math.hypot(newX - state.player.x, newY - state.player.y) < 100 ||
                 Math.hypot(newX - state.monster.x, newY - state.monster.y) < 80) &&
                attempts < 30
            );

            if (attempts < 30) {
                state.tracks.push({
                    x: newX, y: newY,
                    size: 12 + Math.random() * 16,
                    shade: Math.random(),
                    isFake: false,
                    found: false
                });
            }
        },

        spawnGate(state, canvasW, canvasH) {
            state.gate.active = true;
            let gateX, gateY, attempts = 0;
            do {
                gateX = 100 + Math.random() * (canvasW - 200);
                gateY = 100 + Math.random() * (canvasH - 200);
                attempts++;
            } while (
                (Math.hypot(gateX - state.player.x, gateY - state.player.y) < 200 ||
                 Math.hypot(gateX - state.monster.x, gateY - state.monster.y) < 300) &&
                attempts < 50
            );
            state.gate.x = gateX;
            state.gate.y = gateY;
        }
    };

    // ════════════════════════════════════════
    // 13. AbilitySystem
    // ════════════════════════════════════════
    class AbilitySystem {
        constructor(state, whisper, canvas) {
            this.state = state;
            this.whisper = whisper;
            this.canvas = canvas;
        }

        update(dt) {
            const now = Date.now();
            this.updateTeleport(now, dt);
            this.updateLightsOut(now);
            this.updateDarkPulse(now);
        }

        updateTeleport(now, dt) {
            const s = this.state;
            if (now - s.teleportTimer > s.teleportCooldown) {
                const dist = s.flashRadius * 0.8;
                s.monster.x = Math.max(30, Math.min(this.canvas.width - 30,
                    s.player.x + Math.cos(s.player.angle) * dist));
                s.monster.y = Math.max(30, Math.min(this.canvas.height - 30,
                    s.player.y + Math.sin(s.player.angle) * dist));
                s.teleportTimer = now;
                s.teleportFlash = 800;
            }
            if (s.teleportFlash > 0) s.teleportFlash -= dt;
        }

        updateLightsOut(now) {
            const s = this.state;
            if (s.lightsOutPhase === 'none' && now - s.lightsOutTimer > LIGHTS_OUT_INTERVAL) {
                s.lightsOutPhase = 'flicker';
                s.lightsOutStart = now;
            }
            if (s.lightsOutPhase === 'flicker' && now - s.lightsOutStart > LIGHTS_OUT_FLICKER) {
                s.lightsOutPhase = 'dark';
                s.lightsOutStart = now;
                UI.shake(s, 4, 500);
            }
            if (s.lightsOutPhase === 'dark' && now - s.lightsOutStart > LIGHTS_OUT_DARK) {
                s.lightsOutPhase = 'none';
                s.lightsOutTimer = now;
            }
        }

        updateDarkPulse(now) {
            const s = this.state;
            if (!s.darkPulseActive && now - s.darkPulseTimer > DARK_PULSE_INTERVAL) {
                s.darkPulseActive = true;
                s.darkPulseTimer = now;
                UI.shake(s, 6, 400);
                this.whisper.start();
            }
            if (s.darkPulseActive && now - s.darkPulseTimer > DARK_PULSE_DURATION) {
                s.darkPulseActive = false;
                s.darkPulseTimer = now;
                this.whisper.stop();
            }
        }
    }

    // ════════════════════════════════════════
    // 14. CollisionSystem
    // ════════════════════════════════════════
    class CollisionSystem {
        constructor(state, particles, jumpscare, heartbeat, victory, canvas) {
            this.state = state;
            this.particles = particles;
            this.jumpscare = jumpscare;
            this.heartbeat = heartbeat;
            this.victory = victory;
            this.canvas = canvas;
        }

        check() {
            const s = this.state;
            const monsterDist = Math.hypot(s.player.x - s.monster.x, s.player.y - s.monster.y);
            if (monsterDist < s.minMonsterDist) s.minMonsterDist = monsterDist;

            this.heartbeat.updateProximity(monsterDist);
            this.checkMonsterCatch(monsterDist);
            if (!s.gameOver) this.checkGate();
            if (!s.gameOver) this.collectTracks();
        }

        checkMonsterCatch(dist) {
            const s = this.state;
            if (dist < CATCH_DISTANCE) {
                s.gameOver = true;
                s.won = false;
                UI.shake(s, 15, 500);
                this.jumpscare.trigger();
                UI.showMessage('&#x1F480; DU WURDEST ERWISCHT!<br><small>R = Neustart</small>');
            }
        }

        checkGate() {
            const s = this.state;
            if (!s.gate.active) return;
            const gateDist = Math.hypot(s.player.x - s.gate.x, s.player.y - s.gate.y);
            if (gateDist < s.gate.radius) {
                s.gameOver = true;
                s.won = true;
                this.victory.trigger(s);
            }
        }

        collectTracks() {
            const s = this.state;
            s.tracks.forEach(track => {
                if (track.found) return;
                const dist = Math.hypot(track.x - s.player.x, track.y - s.player.y);
                if (dist > COLLECT_DISTANCE) return;

                const angle = Math.atan2(track.y - s.player.y, track.x - s.player.x);
                let angleDiff = angle - s.player.angle;
                while (angleDiff > Math.PI) angleDiff -= TWO_PI;
                while (angleDiff < -Math.PI) angleDiff += TWO_PI;
                if (Math.abs(angleDiff) > s.flashCone / 2) return;

                track.found = true;

                if (track.isFake) {
                    s.found = Math.max(0, s.found - 1);
                    UI.shake(s, 6, 250);
                    this.particles.spawn(track.x, track.y, '#00ff00', 12);
                    UI.showToast(s, '&#x26A0;&#xFE0F; FALSCHE SPUR! -1', '#ff6600', 1500);
                    SFX.fakeCollect();
                    Spawner.spawnReplacementTrack(s, this.canvas.width, this.canvas.height);
                } else {
                    s.found++;
                    this.particles.spawn(track.x, track.y, '#ff0000', 10);
                    SFX.bloodCollect();
                }

                document.getElementById('score').textContent = s.found;
                const remaining = s.tracks.filter(tr => !tr.found && !tr.isFake).length;
                document.getElementById('remaining').textContent = remaining;

                if ((s.found >= s.total || remaining === 0) && !s.gate.active) {
                    Spawner.spawnGate(s, this.canvas.width, this.canvas.height);
                    UI.shake(s, 8, 600);
                    UI.showToast(s, '&#x1F6AA; DAS TOR IST OFFEN! FLIEHE!', '#ff00ff', 3000);
                    SFX.gateAppears();
                }
            });
        }
    }

    // ════════════════════════════════════════
    // 15. Renderer
    // ════════════════════════════════════════
    class Renderer {
        constructor(state, particles) {
            this.state = state;
            this.particles = particles;
        }

        render(ctx, canvas) {
            const s = this.state;

            // Victory canvas animation
            if (s.victoryActive) {
                this.renderVictoryCanvas(ctx, canvas);
                return;
            }

            ctx.save();
            ctx.translate(s.shakeX, s.shakeY);

            ctx.fillStyle = '#050505';
            ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);

            this.renderTracks(ctx);
            this.renderMonster(ctx);
            this.renderFlashlight(ctx, canvas);
            this.renderPlayer(ctx);
            this.particles.render(ctx);
            this.renderGate(ctx);
            this.renderDarkPulse(ctx, canvas);
            this.renderVignette(ctx, canvas);

            ctx.restore();
            UI.updateHUD(s);
        }

        renderTracks(ctx) {
            const s = this.state;
            s.tracks.forEach(track => {
                if (track.found) return;
                const dist = Math.hypot(track.x - s.player.x, track.y - s.player.y);
                if (dist > s.flashRadius) return;

                const sh = track.shade;
                const r = Math.floor(100 + sh * 120);
                const g = Math.floor(20 + sh * 20);
                const b = Math.floor(20 + sh * 15);
                const alpha = (1 - dist / s.flashRadius) * (0.5 + sh * 0.5);

                ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                ctx.beginPath();
                const steps = 12;
                for (let i = 0; i < steps; i++) {
                    const angle = (i / steps) * TWO_PI;
                    const wobble = 0.85 + Math.sin(i * 1.8 + track.x * 0.1) * 0.15;
                    const px = track.x + Math.cos(angle) * track.size * wobble;
                    const py = track.y + Math.sin(angle) * track.size * wobble;
                    i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();

                if (track.isFake) {
                    ctx.strokeStyle = `rgba(0, 200, 0, ${alpha * 0.7})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
        }

        renderMonster(ctx) {
            const s = this.state;
            const elapsed = Date.now() / 1000;
            const mx = s.monster.x, my = s.monster.y;

            ctx.fillStyle = '#080808';
            ctx.strokeStyle = '#151515';
            ctx.lineWidth = 1.5;
            for (let i = 0; i < 4; i++) {
                const flap = Math.sin(elapsed * 3 + i * 0.5) * (10 + i * 3);
                const lwx = mx - 38 - flap, lwy = my - 18 + i * 22;
                const rwx = mx + 38 + flap, rwy = my - 18 + i * 22;
                ctx.beginPath();
                ctx.ellipse(lwx, lwy, 28, 10, -0.2, 0, TWO_PI);
                ctx.fill(); ctx.stroke();
                ctx.beginPath();
                ctx.ellipse(rwx, rwy, 28, 10, 0.2, 0, TWO_PI);
                ctx.fill(); ctx.stroke();

                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 10;
                for (let e = 0; e < 4; e++) {
                    const eyeOffset = -20 + e * 13;
                    const eyeGlow = 0.4 + Math.sin(elapsed * 3 + i * 1.5 + e * 0.8) * 0.4;
                    const eyeSize = 1.8 + Math.sin(elapsed * 2 + e) * 0.4;
                    ctx.fillStyle = `rgba(255, 255, 255, ${eyeGlow})`;
                    ctx.beginPath();
                    ctx.arc(lwx + eyeOffset, lwy - 6, eyeSize, 0, TWO_PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(rwx + eyeOffset, rwy - 6, eyeSize, 0, TWO_PI);
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#080808';
            }

            ctx.fillStyle = '#060606';
            ctx.beginPath();
            ctx.ellipse(mx - 18, my - 8, 16, 20, -0.3, 0, TWO_PI);
            ctx.fill(); ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(mx + 18, my - 8, 16, 20, 0.3, 0, TWO_PI);
            ctx.fill(); ctx.stroke();

            const wb = Math.sin(elapsed * 3) * 2;
            ctx.beginPath();
            ctx.ellipse(mx, my + 18, 14 + wb, 16 - wb, 0, 0, TWO_PI);
            ctx.fillStyle = '#040404';
            ctx.fill(); ctx.stroke();

            ctx.beginPath();
            ctx.arc(mx, my - 42, 11, 0, TWO_PI);
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 2.5;
            ctx.stroke();

            const eyeAngle = Math.atan2(s.player.y - my, s.player.x - mx);
            const eyeGlow = 0.6 + Math.sin(elapsed * 4) * 0.4;
            ctx.fillStyle = `rgba(255, 255, 255, ${eyeGlow})`;
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(mx + Math.cos(eyeAngle + 0.2) * 5, my + Math.sin(eyeAngle + 0.2) * 5 - 4, 3.5, 0, TWO_PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(mx + Math.cos(eyeAngle - 0.2) * 5, my + Math.sin(eyeAngle - 0.2) * 5 - 4, 3.5, 0, TWO_PI);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        renderFlashlight(ctx, canvas) {
            const s = this.state;
            let lightR = s.flashRadius;
            let flickerVal = 1;

            if (s.lightsOutPhase === 'flicker') {
                flickerVal = 0.2 + Math.random() * 0.8;
                lightR = s.flashRadius * (0.4 + Math.random() * 0.6);
            } else if (s.lightsOutPhase === 'dark') {
                flickerVal = 0;
            }

            if (flickerVal > 0) {
                ctx.save();
                ctx.globalCompositeOperation = 'destination-in';
                ctx.beginPath();
                ctx.moveTo(s.player.x, s.player.y);
                ctx.arc(s.player.x, s.player.y, lightR,
                    s.player.angle - s.flashCone / 2,
                    s.player.angle + s.flashCone / 2);
                ctx.closePath();
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.restore();

                ctx.save();
                ctx.globalAlpha = 0.12 * flickerVal;
                ctx.beginPath();
                ctx.moveTo(s.player.x, s.player.y);
                ctx.arc(s.player.x, s.player.y, lightR,
                    s.player.angle - s.flashCone / 2,
                    s.player.angle + s.flashCone / 2);
                ctx.closePath();
                ctx.fillStyle = '#ffff88';
                ctx.fill();
                ctx.restore();
            } else {
                ctx.save();
                ctx.globalCompositeOperation = 'destination-in';
                ctx.beginPath();
                ctx.arc(s.player.x, s.player.y, 3, 0, TWO_PI);
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.restore();
            }
        }

        renderPlayer(ctx) {
            const s = this.state;
            ctx.globalCompositeOperation = 'source-over';
            ctx.beginPath();
            ctx.arc(s.player.x, s.player.y, PLAYER_RADIUS, 0, TWO_PI);
            ctx.fillStyle = '#ffcc99';
            ctx.fill();
            ctx.strokeStyle = '#c49070';
            ctx.lineWidth = 2;
            ctx.stroke();

            const pglow = ctx.createRadialGradient(s.player.x, s.player.y, 0, s.player.x, s.player.y, 30);
            pglow.addColorStop(0, 'rgba(255,200,150,0.08)');
            pglow.addColorStop(1, 'transparent');
            ctx.fillStyle = pglow;
            ctx.fillRect(s.player.x - 30, s.player.y - 30, 60, 60);
        }

        renderGate(ctx) {
            const s = this.state;
            if (!s.gate.active) return;

            const elapsed = Date.now() / 1000;
            const gx = s.gate.x, gy = s.gate.y;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';

            const outerRadius = s.gate.radius + 20 + Math.sin(elapsed * 3) * 10;
            const outerGlow = ctx.createRadialGradient(gx, gy, s.gate.radius, gx, gy, outerRadius);
            outerGlow.addColorStop(0, 'rgba(100, 0, 200, 0.4)');
            outerGlow.addColorStop(0.5, 'rgba(150, 0, 255, 0.2)');
            outerGlow.addColorStop(1, 'transparent');
            ctx.fillStyle = outerGlow;
            ctx.beginPath();
            ctx.arc(gx, gy, outerRadius, 0, TWO_PI);
            ctx.fill();

            const innerGlow = ctx.createRadialGradient(gx, gy, 10, gx, gy, s.gate.radius);
            innerGlow.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            innerGlow.addColorStop(0.2, 'rgba(200, 100, 255, 0.8)');
            innerGlow.addColorStop(0.5, 'rgba(150, 0, 200, 0.5)');
            innerGlow.addColorStop(1, 'rgba(80, 0, 150, 0.2)');
            ctx.fillStyle = innerGlow;
            ctx.beginPath();
            ctx.arc(gx, gy, s.gate.radius, 0, TWO_PI);
            ctx.fill();

            ctx.strokeStyle = `rgba(255, 200, 255, ${0.6 + Math.sin(elapsed * 5) * 0.3})`;
            ctx.lineWidth = 3;
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * TWO_PI + elapsed * 2;
                const r1 = 20 + Math.sin(elapsed * 4 + i) * 5;
                const r2 = s.gate.radius - 10;
                ctx.beginPath();
                ctx.moveTo(gx + Math.cos(angle) * r1, gy + Math.sin(angle) * r1);
                ctx.lineTo(gx + Math.cos(angle) * r2, gy + Math.sin(angle) * r2);
                ctx.stroke();
            }

            ctx.fillStyle = `rgba(255, 255, 255, ${0.8 + Math.sin(elapsed * 8) * 0.2})`;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * TWO_PI + elapsed;
                const r = 15 + Math.sin(elapsed * 6 + i * 2) * 5;
                const px = gx + Math.cos(angle) * r;
                const py = gy + Math.sin(angle) * r;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 16px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = '#ff00ff';
            ctx.shadowBlur = 15;
            ctx.fillText('TOR', gx, gy - 35);
            ctx.shadowBlur = 0;

            const distToGate = Math.hypot(this.state.player.x - gx, this.state.player.y - gy);
            if (distToGate > 200) {
                ctx.strokeStyle = 'rgba(255, 0, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(gx, gy, Math.min(distToGate / 2, 100), 0, TWO_PI);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            ctx.restore();
        }

        renderDarkPulse(ctx, canvas) {
            const s = this.state;
            if (!s.darkPulseActive) {
                s.flashRadius = FLASH_RADIUS;
                return;
            }

            const nowMs = Date.now();
            const pulseAlpha = 0.5 + Math.sin(nowMs / 150) * 0.2;
            ctx.fillStyle = `rgba(60, 0, 80, ${pulseAlpha})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (Math.random() < 0.4) {
                const side = Math.floor(Math.random() * 4);
                const px = side < 2 ? Math.random() * canvas.width : (side === 2 ? 0 : canvas.width);
                const py = side >= 2 ? Math.random() * canvas.height : (side === 0 ? 0 : canvas.height);
                const colors = ['#8800ff', '#4400aa', '#660088'];
                this.particles.spawn(px, py, colors[Math.floor(Math.random() * colors.length)], 2 + Math.floor(Math.random() * 3));
            }

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const ts = nowMs / 1000;
            const w = canvas.width, h = canvas.height;

            const leftCount = 5 + Math.floor(Math.abs(Math.sin(ts * 0.1)) * 4);
            const rightCount = 5 + Math.floor(Math.abs(Math.sin(ts * 0.12 + 1)) * 4);
            const topCount = 4 + Math.floor(Math.abs(Math.sin(ts * 0.08 + 2)) * 3);
            const bottomCount = 4 + Math.floor(Math.abs(Math.sin(ts * 0.11 + 3)) * 3);

            for (let v = 0; v < leftCount; v++) {
                const yPos = h * (0.08 + v * (0.85 / leftCount)) + Math.sin(ts * 0.2 + v * 2) * 30;
                const thick = 1.5 + Math.abs(Math.sin(v * 3.3)) * 2.5;
                this.drawOrganicVine(ctx, 0, yPos, 1, Math.sin(ts * 0.15 + v) * 0.15, h * 0.22, v * 1.7 + ts, thick);
            }
            for (let v = 0; v < rightCount; v++) {
                const yPos = h * (0.05 + v * (0.9 / rightCount)) + Math.cos(ts * 0.25 + v * 1.5) * 35;
                const thick = 1.5 + Math.abs(Math.sin(v * 4.1 + 10)) * 2.5;
                this.drawOrganicVine(ctx, w, yPos, -1, Math.cos(ts * 0.18 + v + 5) * 0.12, h * 0.25, v * 2.3 + ts + 100, thick);
            }
            for (let v = 0; v < topCount; v++) {
                const xPos = w * (0.1 + v * (0.8 / topCount)) + Math.sin(ts * 0.22 + v * 2.2) * 40;
                const thick = 1.5 + Math.abs(Math.sin(v * 3.9 + 20)) * 2;
                this.drawOrganicVine(ctx, xPos, 0, Math.sin(ts * 0.12 + v + 3) * 0.1, 1, w * 0.18, v * 1.9 + ts + 200, thick);
            }
            for (let v = 0; v < bottomCount; v++) {
                const xPos = w * (0.12 + v * (0.76 / bottomCount)) + Math.cos(ts * 0.19 + v * 1.8) * 35;
                const thick = 1.5 + Math.abs(Math.sin(v * 4.7 + 30)) * 2;
                this.drawOrganicVine(ctx, xPos, h, Math.cos(ts * 0.14 + v + 7) * 0.08, -1, w * 0.18, v * 2.1 + ts + 300, thick);
            }

            ctx.restore();

            ctx.save();
            for (let side = 0; side < 4; side++) {
                let fog;
                if (side === 0) { fog = ctx.createLinearGradient(0, 0, 0, h * 0.15); }
                else if (side === 1) { fog = ctx.createLinearGradient(0, h, 0, h * 0.85); }
                else if (side === 2) { fog = ctx.createLinearGradient(0, 0, w * 0.12, 0); }
                else { fog = ctx.createLinearGradient(w, 0, w * 0.88, 0); }
                const fogAlpha = 0.2 + Math.sin(nowMs / (300 + side * 50) + side) * 0.1;
                fog.addColorStop(0, `rgba(80, 0, 120, ${fogAlpha})`);
                fog.addColorStop(1, 'transparent');
                ctx.fillStyle = fog;
                if (side === 0) ctx.fillRect(0, 0, w, h * 0.15);
                else if (side === 1) ctx.fillRect(0, h * 0.85, w, h * 0.15);
                else if (side === 2) ctx.fillRect(0, 0, w * 0.12, h);
                else ctx.fillRect(w * 0.88, 0, w * 0.12, h);
            }
            ctx.restore();

            s.flashRadius = FLASH_RADIUS - 30 - Math.random() * 60;
        }

        drawOrganicVine(ctx, startX, startY, dirX, dirY, baseLength, seed, thickness) {
            const ts = Date.now() / 1000;
            const segments = 8 + Math.floor(Math.abs(Math.sin(seed * 7.3)) * 8);
            const curveFreq1 = 0.5 + Math.abs(Math.sin(seed * 3.1)) * 1.5;
            const curveFreq2 = 0.8 + Math.abs(Math.sin(seed * 4.7)) * 2.2;
            const curveAmp1 = 15 + Math.abs(Math.sin(seed * 2.9)) * 25;
            const curveAmp2 = 8 + Math.abs(Math.sin(seed * 5.3)) * 15;
            const length = baseLength * (0.7 + Math.abs(Math.sin(seed * 1.8)) * 0.6);
            const speed1 = 0.3 + Math.abs(Math.sin(seed * 6.2)) * 0.7;
            const speed2 = 0.4 + Math.abs(Math.sin(seed * 3.8)) * 0.8;

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            let cx = startX, cy = startY, prevX = startX, prevY = startY;

            for (let i = 1; i <= segments; i++) {
                const progress = i / segments;
                const wave1 = Math.sin(ts * speed1 + seed + progress * curveFreq1 * 3) * curveAmp1 * (1 - progress * 0.3);
                const wave2 = Math.cos(ts * speed2 + seed * 2.1 + progress * curveFreq2 * 4) * curveAmp2 * (1 - progress * 0.5);
                const wave3 = Math.sin(ts * 0.6 + seed * 3.7 + progress * 7) * 8 * (1 - progress);

                const perpX = -dirY, perpY = dirX;
                cx += dirX * (length / segments);
                cy += dirY * (length / segments);

                const organicX = cx + perpX * (wave1 + wave2 + wave3);
                const organicY = cy + perpY * (wave1 + wave2 + wave3);

                const cpX = (prevX + organicX) / 2 + perpX * Math.sin(ts + seed + i) * 5;
                const cpY = (prevY + organicY) / 2 + perpY * Math.sin(ts + seed + i) * 5;

                ctx.quadraticCurveTo(cpX, cpY, organicX, organicY);
                prevX = organicX; prevY = organicY;
            }

            const hue = 260 + Math.sin(seed * 8.5) * 30;
            const alpha = 0.15 + Math.abs(Math.sin(ts * 0.4 + seed)) * 0.15;
            ctx.strokeStyle = `hsla(${hue}, 80%, 40%, ${alpha})`;
            ctx.lineWidth = thickness * (0.6 + Math.abs(Math.sin(ts * 0.3 + seed)) * 0.8);
            ctx.lineCap = 'round';
            ctx.stroke();

            if (Math.abs(Math.sin(seed * 9.7)) > 0.6 && length > 80) {
                const branchPoint = 0.3 + Math.abs(Math.sin(seed * 2.4)) * 0.4;
                const bx = startX + dirX * length * branchPoint;
                const by = startY + dirY * length * branchPoint;
                const sign = Math.sin(seed * 5.5) > 0 ? 1 : -1;
                const branchDirX = dirX * Math.cos(0.8) - dirY * Math.sin(0.8) * sign;
                const branchDirY = dirX * Math.sin(0.8) + dirY * Math.cos(0.8) * sign;
                this.drawOrganicVine(ctx, bx, by, branchDirX, branchDirY, length * 0.5, seed * 1.5, thickness * 0.6);
            }
        }

        renderVictoryCanvas(ctx, canvas) {
            const s = this.state;
            const elapsed = (Date.now() - s.victoryTime) / 1000;
            const w = canvas.width, h = canvas.height;

            // Phase 1 (0-1.8s): Canvas effects before overlay
            // Background: dark -> gradually brightening
            const brightness = Math.min(1, elapsed / 1.8);
            const bgR = Math.floor(5 + brightness * 30);
            const bgG = Math.floor(5 + brightness * 25);
            const bgB = Math.floor(5 + brightness * 15);
            ctx.fillStyle = `rgb(${bgR},${bgG},${bgB})`;
            ctx.fillRect(0, 0, w, h);

            // Expanding light ring from gate
            const gx = s.gate.x, gy = s.gate.y;
            const ringRadius = elapsed * 400;
            const ringAlpha = Math.max(0, 1 - elapsed / 2);

            if (ringAlpha > 0) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                // Outer glow ring
                const ringGrad = ctx.createRadialGradient(gx, gy, Math.max(0, ringRadius - 40), gx, gy, ringRadius + 20);
                ringGrad.addColorStop(0, 'transparent');
                ringGrad.addColorStop(0.4, `rgba(255, 220, 100, ${ringAlpha * 0.6})`);
                ringGrad.addColorStop(0.6, `rgba(255, 255, 200, ${ringAlpha * 0.8})`);
                ringGrad.addColorStop(0.8, `rgba(255, 220, 100, ${ringAlpha * 0.4})`);
                ringGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = ringGrad;
                ctx.fillRect(0, 0, w, h);

                // Central bright flash
                if (elapsed < 0.5) {
                    const flashAlpha = 1 - elapsed / 0.5;
                    const flashGrad = ctx.createRadialGradient(gx, gy, 0, gx, gy, 200 + elapsed * 300);
                    flashGrad.addColorStop(0, `rgba(255, 255, 255, ${flashAlpha})`);
                    flashGrad.addColorStop(0.3, `rgba(255, 240, 180, ${flashAlpha * 0.7})`);
                    flashGrad.addColorStop(1, 'transparent');
                    ctx.fillStyle = flashGrad;
                    ctx.fillRect(0, 0, w, h);
                }

                // Golden particles from gate
                if (elapsed < 1.5 && Math.random() < 0.6) {
                    const colors = ['#ffdd44', '#ffaa00', '#ffffff', '#ffee88'];
                    this.particles.spawn(
                        gx + (Math.random() - 0.5) * 80,
                        gy + (Math.random() - 0.5) * 80,
                        colors[Math.floor(Math.random() * colors.length)],
                        3 + Math.floor(Math.random() * 4)
                    );
                }

                // Light rays from gate
                ctx.strokeStyle = `rgba(255, 220, 100, ${ringAlpha * 0.3})`;
                ctx.lineWidth = 2;
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * TWO_PI + elapsed * 0.5;
                    const r1 = 30 + Math.sin(elapsed * 3 + i) * 10;
                    const r2 = ringRadius * 0.8;
                    ctx.beginPath();
                    ctx.moveTo(gx + Math.cos(angle) * r1, gy + Math.sin(angle) * r1);
                    ctx.lineTo(gx + Math.cos(angle) * r2, gy + Math.sin(angle) * r2);
                    ctx.stroke();
                }

                ctx.restore();
            }

            // Monster dissolving (recoils and fades)
            if (elapsed < 1.8) {
                const dissolve = Math.min(1, elapsed / 1.5);
                const recoilDist = dissolve * 150;
                const monAngle = Math.atan2(s.monster.y - gx, s.monster.x - gy);
                const mx = s.monster.x + Math.cos(monAngle) * recoilDist;
                const my = s.monster.y + Math.sin(monAngle) * recoilDist;
                const monAlpha = Math.max(0, 1 - dissolve);
                const monScale = Math.max(0.1, 1 - dissolve * 0.8);

                ctx.save();
                ctx.globalAlpha = monAlpha;
                ctx.translate(mx, my);
                ctx.scale(monScale, monScale);
                ctx.translate(-mx, -my);

                // Monster eyes go from white to golden to gone
                const eyeColor = dissolve < 0.5
                    ? `rgba(255, ${Math.floor(200 + dissolve * 110)}, ${Math.floor(dissolve * 200)}, ${monAlpha})`
                    : `rgba(255, 220, 100, ${monAlpha})`;
                ctx.fillStyle = eyeColor;
                ctx.shadowColor = '#ffdd44';
                ctx.shadowBlur = 20 * monAlpha;
                ctx.beginPath();
                ctx.arc(mx - 5, my - 4, 3.5, 0, TWO_PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(mx + 5, my - 4, 3.5, 0, TWO_PI);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Dissolve particles from monster
                if (Math.random() < 0.5 * monAlpha) {
                    this.particles.spawn(mx + (Math.random() - 0.5) * 30, my + (Math.random() - 0.5) * 30, '#ffdd44', 2);
                }

                ctx.restore();
            }

            // Player still visible, glowing golden
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            const playerGlow = Math.min(1, elapsed / 0.5);
            const pglow = ctx.createRadialGradient(s.player.x, s.player.y, 0, s.player.x, s.player.y, 50 + playerGlow * 30);
            pglow.addColorStop(0, `rgba(255, 230, 150, ${0.3 * playerGlow})`);
            pglow.addColorStop(1, 'transparent');
            ctx.fillStyle = pglow;
            ctx.fillRect(s.player.x - 80, s.player.y - 80, 160, 160);
            ctx.beginPath();
            ctx.arc(s.player.x, s.player.y, PLAYER_RADIUS, 0, TWO_PI);
            ctx.fillStyle = `rgb(${255}, ${Math.floor(204 + playerGlow * 40)}, ${Math.floor(153 + playerGlow * 80)})`;
            ctx.fill();
            ctx.strokeStyle = `rgb(${Math.floor(196 + playerGlow * 59)}, ${Math.floor(144 + playerGlow * 76)}, ${Math.floor(112 + playerGlow * 60)})`;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();

            // Update particles
            this.particles.update();
            this.particles.render(ctx);

            // Fade to white before overlay
            if (elapsed > 1.2 && elapsed < 2) {
                const fadeAlpha = Math.min(1, (elapsed - 1.2) / 0.8);
                ctx.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`;
                ctx.fillRect(0, 0, w, h);
            }
        }

        renderVignette(ctx, canvas) {
            const s = this.state;
            const monsterDist = Math.hypot(s.monster.x - s.player.x, s.monster.y - s.player.y);
            let danger = 0;
            if (monsterDist < PROXIMITY_DISTANCE && !s.gameOver) {
                danger = Math.max(danger, (1 - monsterDist / PROXIMITY_DISTANCE) * 0.5);
            }
            if (s.teleportFlash > 0) {
                danger = Math.max(danger, (s.teleportFlash / 800) * 0.7);
            }

            if (danger > 0) {
                const vg = ctx.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, canvas.height * 0.25,
                    canvas.width / 2, canvas.height / 2, canvas.height * 0.75);
                vg.addColorStop(0, 'transparent');
                vg.addColorStop(1, `rgba(255,0,0,${danger})`);
                ctx.fillStyle = vg;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }
    }

    // ════════════════════════════════════════
    // 16. Game
    // ════════════════════════════════════════
    class Game {
        constructor() {
            this.canvas = document.getElementById('game');
            this.ctx = this.canvas.getContext('2d');
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            window.addEventListener('resize', () => {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            });

            this.state = new GameState();
            this.audio = new AudioManager();
            this.organ = new OrganSound(this.audio);
            this.heartbeat = new HeartbeatSound(this.audio);
            this.whisper = new WhisperSound(this.audio);
            this.jumpscare = new JumpscareSystem(this.audio);
            this.victory = new VictorySystem(this.audio);
            this.input = new InputManager();
            this.particles = new ParticleSystem(this.state);
            this.abilities = new AbilitySystem(this.state, this.whisper, this.canvas);
            this.collisions = new CollisionSystem(this.state, this.particles, this.jumpscare, this.heartbeat, this.victory, this.canvas);
            this.renderer = new Renderer(this.state, this.particles);

            SFX.init(this.audio);

            this.input.init(() => {
                if (this.state.gameOver) this.init();
            });

            this.lastTime = 0;

            document.getElementById('startBtn').addEventListener('click', () => this.start());
        }

        init() {
            this.state.reset(this.canvas.width, this.canvas.height);

            Spawner.spawnTracks(this.state, this.canvas.width, this.canvas.height);
            Spawner.spawnMonster(this.state, this.canvas.width, this.canvas.height);

            document.getElementById('score').textContent = '0';
            document.getElementById('total').textContent = this.state.total;
            document.getElementById('remaining').textContent = this.state.total;
            document.getElementById('message').style.display = 'none';
            document.getElementById('toast').style.opacity = 0;
            this.victory.hide();

            if (this.audio.started) {
                this.stopAllAudio();
                this.organ.start(this.state);
            }
        }

        stopAllAudio() {
            this.organ.stop();
            this.whisper.stop();
            this.heartbeat.stop();
        }

        start() {
            document.getElementById('startscreen').style.display = 'none';
            this.state.started = true;
            this.audio.init();
            this.init();
        }

        loop(timestamp) {
            const dt = Math.min(timestamp - this.lastTime, 50);
            this.lastTime = timestamp;
            if (this.state.started) {
                this.update(dt);
                this.renderer.render(this.ctx, this.canvas);
            }
            requestAnimationFrame(ts => this.loop(ts));
        }

        update(dt) {
            // Victory canvas animation continues after gameOver
            if (this.state.victoryActive) {
                this.particles.update();
                return;
            }
            if (this.state.gameOver) return;

            UI.updateToast(this.state, dt);
            UI.updateShake(this.state, dt);
            this.processMovement(dt);
            this.updateMonsterChase();
            this.abilities.update(dt);
            this.collisions.check();
            this.particles.update();

            if (this.state.gameOver) {
                this.stopAllAudio();
            }
        }

        processMovement(dt) {
            const s = this.state;
            let dx = 0, dy = 0;
            if (this.input.isDown('w') || this.input.isDown('arrowup')) dy = -1;
            if (this.input.isDown('s') || this.input.isDown('arrowdown')) dy = 1;
            if (this.input.isDown('a') || this.input.isDown('arrowleft')) dx = -1;
            if (this.input.isDown('d') || this.input.isDown('arrowright')) dx = 1;

            const speedMod = s.darkPulseActive ? 0.65 : 1;
            if (dx !== 0 || dy !== 0) {
                const len = Math.hypot(dx, dy);
                dx /= len; dy /= len;
                s.player.x = Math.max(15, Math.min(this.canvas.width - 15, s.player.x + dx * s.player.speed * speedMod));
                s.player.y = Math.max(15, Math.min(this.canvas.height - 15, s.player.y + dy * s.player.speed * speedMod));
                s.player.angle = Math.atan2(dy, dx);
            }
        }

        updateMonsterChase() {
            const s = this.state;
            const diffX = s.player.x - s.monster.x;
            const diffY = s.player.y - s.monster.y;
            const dist = Math.hypot(diffX, diffY);
            const monsterMod = s.darkPulseActive ? 2.0 : 1;
            if (dist > 0) {
                s.monster.x += (diffX / dist) * s.monster.speed * monsterMod;
                s.monster.y += (diffY / dist) * s.monster.speed * monsterMod;
            }
        }

        run() {
            requestAnimationFrame(ts => this.loop(ts));
        }
    }

    // ════════════════════════════════════════
    // START
    // ════════════════════════════════════════
    const game = new Game();
    game.run();
    </script>
</body>
</html>
