<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flucht im Dunkeln</title>
    <style>
        * { margin: 0; padding: 0; }
        body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 15px; left: 15px;
            color: #ff3333; font-size: 18px;
            text-shadow: 0 0 10px #ff0000;
            pointer-events: none; z-index: 10;
        }
        #timer {
            position: absolute; top: 15px; right: 15px;
            color: #888; font-size: 16px;
            pointer-events: none; z-index: 10;
        }
        /* abilities removed */
        #message {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000; font-size: 36px; text-align: center;
            text-shadow: 0 0 30px currentColor;
            display: none; pointer-events: none; z-index: 20;
            transition: opacity 0.5s;
        }
        #toast {
            position: absolute; top: 75px; left: 50%;
            transform: translateX(-50%);
            color: #ff6600; font-size: 20px; text-align: center;
            text-shadow: 0 0 15px currentColor;
            opacity: 0; pointer-events: none; z-index: 15;
            transition: opacity 0.3s;
        }
        #instructions {
            position: absolute; bottom: 15px; left: 15px;
            color: #555; font-size: 13px;
            pointer-events: none; z-index: 10;
        }
        #startscreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 50;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            color: #ff3333; text-align: center;
        }
        #startscreen h1 {
            font-size: 48px; text-shadow: 0 0 40px #ff0000;
            margin-bottom: 20px; animation: flicker 3s infinite;
        }
        #startscreen p { color: #888; font-size: 16px; margin: 8px 0; max-width: 500px; }
        #startscreen .start-btn {
            margin-top: 30px; padding: 15px 40px;
            background: none; border: 2px solid #ff3333;
            color: #ff3333; font-family: inherit; font-size: 20px;
            cursor: pointer; transition: all 0.3s;
        }
        #startscreen .start-btn:hover {
            background: #ff3333; color: #000;
            box-shadow: 0 0 30px #ff0000;
        }
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            92% { opacity: 1; }
            93% { opacity: 0.3; }
        }
        
        /* JUMPSCARE overlay - Gefallener Engel */
        #jumpscare {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999; display: none;
            align-items: center; justify-content: center;
            flex-direction: column;
            overflow: hidden;
        }
        #jumpscare.active { display: flex; }
        #jumpscare .scare-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* Gesicht des gefallenen Engels - reines CSS */
        #jumpscare .angel-face {
            position: relative;
            width: 40vmin;
            height: 50vmin;
            animation: faceShake 0.08s infinite;
        }
        /* Sch√§del-Form */
        #jumpscare .skull {
            position: absolute;
            width: 100%;
            height: 80%;
            background: radial-gradient(ellipse at center, #1a0a0a 0%, #0a0000 60%, #000 100%);
            border-radius: 45% 45% 35% 35%;
            box-shadow: 0 0 80px #ff0000, 0 0 120px #880000, inset 0 0 60px rgba(255,0,0,0.3);
        }
        /* Augenh√∂hlen */
        #jumpscare .eye {
            position: absolute;
            width: 28%;
            height: 25%;
            top: 25%;
            background: #000;
            border-radius: 50% 50% 45% 45%;
            box-shadow: 0 0 40px #ff0000, 0 0 80px #ff0000, inset 0 0 20px #ff3300;
            animation: eyeFlicker 0.15s infinite;
        }
        #jumpscare .eye.left { left: 12%; }
        #jumpscare .eye.right { right: 12%; }
        /* Pupillen - gl√ºhend */
        #jumpscare .eye::after {
            content: '';
            position: absolute;
            width: 40%;
            height: 50%;
            top: 25%;
            left: 30%;
            background: radial-gradient(circle, #ffffff 0%, #ff0000 40%, #ff0000 60%, transparent 100%);
            border-radius: 50%;
            animation: pupilPulse 0.1s infinite;
        }
        /* Mund - aufgerissen */
        #jumpscare .mouth {
            position: absolute;
            width: 50%;
            height: 20%;
            bottom: 15%;
            left: 25%;
            background: #000;
            border-radius: 10% 10% 45% 45%;
            box-shadow: 0 0 30px #880000, inset 0 -10px 20px #220000;
            overflow: hidden;
        }
        /* Z√§hne */
        #jumpscare .mouth::before {
            content: '';
            position: absolute;
            top: 0;
            left: 5%;
            width: 90%;
            height: 30%;
            background: repeating-linear-gradient(90deg,
                transparent 0%, transparent 8%,
                #442222 8%, #553333 12%,
                transparent 12%, transparent 20%
            );
        }
        /* Gebrochener Halo */
        #jumpscare .broken-halo {
            position: absolute;
            top: -8%;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 15%;
            border: 4px solid #880000;
            border-radius: 50%;
            border-bottom: none;
            box-shadow: 0 0 20px #ff0000, 0 0 40px #880000;
            animation: haloFlicker 0.2s infinite;
            clip-path: polygon(0 0, 45% 0, 40% 100%, 0 100%, 0 0, 60% 100%, 55% 0, 100% 0, 100% 100%, 60% 100%);
        }
        /* Risse im Gesicht */
        #jumpscare .crack {
            position: absolute;
            width: 3px;
            background: linear-gradient(to bottom, #ff0000, #880000, transparent);
            box-shadow: 0 0 8px #ff0000;
            animation: crackGlow 0.3s infinite alternate;
        }
        #jumpscare .crack.c1 { height: 40%; top: 20%; left: 35%; transform: rotate(-15deg); }
        #jumpscare .crack.c2 { height: 30%; top: 30%; right: 30%; transform: rotate(10deg); }
        #jumpscare .crack.c3 { height: 25%; top: 45%; left: 45%; transform: rotate(5deg); }
        /* Blut-Tr√§nen */
        #jumpscare .blood-tear {
            position: absolute;
            width: 8px;
            height: 30%;
            top: 45%;
            background: linear-gradient(to bottom, #ff0000, #880000, transparent);
            border-radius: 0 0 50% 50%;
            animation: tearDrip 0.8s infinite;
        }
        #jumpscare .blood-tear.left { left: 22%; }
        #jumpscare .blood-tear.right { right: 22%; }
        /* Text */
        #jumpscare .death-text {
            position: absolute;
            bottom: 10%;
            font-size: 5vmin;
            color: #880000;
            text-shadow: 0 0 20px #ff0000, 0 0 40px #880000;
            letter-spacing: 8px;
            animation: textReveal 0.5s ease-out;
        }
        @keyframes faceShake {
            0% { transform: translate(-2px, 1px) rotate(-1deg); }
            25% { transform: translate(2px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, -2px) rotate(-0.5deg); }
            75% { transform: translate(1px, 2px) rotate(0.5deg); }
            100% { transform: translate(-2px, 1px) rotate(-1deg); }
        }
        @keyframes eyeFlicker {
            0%, 100% { box-shadow: 0 0 40px #ff0000, 0 0 80px #ff0000, inset 0 0 20px #ff3300; }
            50% { box-shadow: 0 0 60px #ff0000, 0 0 120px #ff3300, inset 0 0 40px #ff6600; }
        }
        @keyframes pupilPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }
        @keyframes haloFlicker {
            0%, 100% { opacity: 1; border-color: #880000; }
            30% { opacity: 0.3; border-color: #ff0000; }
            60% { opacity: 0.8; border-color: #660000; }
        }
        @keyframes crackGlow {
            0% { box-shadow: 0 0 5px #ff0000; }
            100% { box-shadow: 0 0 15px #ff0000, 0 0 25px #880000; }
        }
        @keyframes tearDrip {
            0% { height: 20%; opacity: 0.8; }
            50% { height: 35%; opacity: 1; }
            100% { height: 20%; opacity: 0.6; }
        }
        @keyframes textReveal {
            0% { opacity: 0; letter-spacing: 30px; }
            100% { opacity: 1; letter-spacing: 8px; }
        }
    </style>
</head>
<body>
    <div id="startscreen">
        <h1>üî¶ FLUCHT IM DUNKELN</h1>
        <p style="color:#aaa; font-style:italic;">Ein Engel ist gefallen.</p>
        <p>Einst ein W√§chter des Himmels ‚Äî jetzt wandert er durch die Dunkelheit, getrieben von unstillbarem <span style="color:#ff0000">Blutdurst</span>.</p>
        <p>Er jagt Menschen. Aber er ist... <span style="color:#ff4444">fair</span>.</p>
        <p style="color:#aaa;">Jetzt ist er bekannt als der <span style="color:#ff0000; font-size:20px; text-shadow: 0 0 15px #ff0000;">CELESTIAL</span>.</p>
        <p style="color:#ccc; margin-top:10px;">Sammle f√ºr ihn alle Blutspuren, w√§hrend er dich jagt ‚Äî und er l√§sst dich am Leben.</p>
        <p style="color:#ff6600; margin-top:15px;">‚ö†Ô∏è Vorsicht: Manche Spuren sind <span style="color:#00cc00">FAKE</span>! Sie kosten dich Punkte.</p>
        <p style="color:#555; margin-top:15px; font-size:13px;">
            WASD / Pfeiltasten = Bewegen<br>
            R = Neustart
        </p>
        <button class="start-btn" onclick="startGame()">‚ñ∂ SPIELEN</button>
    </div>
    <div id="ui">Spuren: <span id="score">0</span> / <span id="total">0</span> | Verbleibend: <span id="remaining">0</span></div>
    <div id="timer">Zeit: 0s</div>
    <!-- abilities removed -->
    <div id="message"></div>
    <div id="toast"></div>
    <div id="instructions">WASD / Pfeile ‚Ä¢ R = Neustart</div>
    <div id="jumpscare">
        <div class="scare-container">
            <div class="angel-face">
                <div class="skull">
                    <div class="broken-halo"></div>
                    <div class="eye left"></div>
                    <div class="eye right"></div>
                    <div class="mouth"></div>
                    <div class="crack c1"></div>
                    <div class="crack c2"></div>
                    <div class="crack c3"></div>
                    <div class="blood-tear left"></div>
                    <div class="blood-tear right"></div>
                </div>
            </div>
            <div class="death-text">ER HAT DICH GEFUNDEN</div>
        </div>
    </div>
    <canvas id="game"></canvas>

    <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });

    // ‚îÄ‚îÄ‚îÄ CONSTANTS ‚îÄ‚îÄ‚îÄ
    const FLASH_RADIUS = 260;
    const HALF_CONE = Math.PI / 3.8;
    const TELEPORT_COOLDOWN = 8000;
    const LIGHTS_OUT_INTERVAL = 13000;
    const LIGHTS_OUT_FLICKER = 3000;
    const LIGHTS_OUT_DARK = 2000;
    const DARK_PULSE_INTERVAL = 20000;
    const DARK_PULSE_DURATION = 4000;
    const PLAYER_RADIUS = 11;
    const CATCH_DISTANCE = 28;
    const COLLECT_DISTANCE = 35;
    const PROXIMITY_DISTANCE = 200;
    const SPAWN_MIN_DISTANCE = 400;
    const TRACK_SPAWN_MIN_DISTANCE = 180;
    const FAKE_TRACK_SPAWN_MIN_DISTANCE = 150;
    const TWO_PI = Math.PI * 2;

    // ‚îÄ‚îÄ‚îÄ GAME STATE ‚îÄ‚îÄ‚îÄ
    const G = {
        player: { x: 0, y: 0, speed: 3.2, angle: 0 },
        tracks: [],
        monster: { x: 0, y: 0, speed: 0.7 },
        particles: [],
        shakeX: 0, shakeY: 0, shakeDur: 0,
        // Abilities
        teleportTimer: 0, teleportCooldown: TELEPORT_COOLDOWN, teleportFlash: 0,
        lightsOutTimer: 0, lightsOutPhase: 'none', lightsOutStart: 0,
        darkPulseTimer: 0, darkPulseActive: false,
        // Game
        startTime: 0, found: 0, total: 0,
        gameOver: false, won: false, started: false,
        flashRadius: FLASH_RADIUS, flashCone: HALF_CONE * 2,
        // Toast
        toastTimer: 0,
        // Exit gate
        gate: { x: 0, y: 0, active: false, radius: 60 }
    };

    // ‚îÄ‚îÄ‚îÄ AUDIO ‚îÄ‚îÄ‚îÄ
    let audioCtx = null, masterGain = null, organGain = null, heartGain = null, whisperGain = null, jumpscareGain = null;
    let audioStarted = false, organInterval = null, heartInterval = null, whisperInterval = null;
    let proximityHeartActive = false;

    function initAudio() {
        if (audioStarted) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.8;
        masterGain.connect(audioCtx.destination);

        organGain = audioCtx.createGain();
        organGain.gain.value = 0.2;
        organGain.connect(masterGain);

        heartGain = audioCtx.createGain();
        heartGain.gain.value = 0;
        heartGain.connect(masterGain);

        whisperGain = audioCtx.createGain();
        whisperGain.gain.value = 0;
        whisperGain.connect(masterGain);

        jumpscareGain = audioCtx.createGain();
        jumpscareGain.gain.value = 1.0;
        jumpscareGain.connect(audioCtx.destination); // bypass master for LOUD

        audioStarted = true;
        startOrgan();
    }

    // ‚îÄ‚îÄ‚îÄ üéµ EERIE ORGAN ‚îÄ‚îÄ‚îÄ
    function playOrganNote(freq, dur) {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        filter.Q.value = 2;
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.3, t + 0.3);
        g.gain.linearRampToValueAtTime(0.15, t + dur * 0.6);
        g.gain.exponentialRampToValueAtTime(0.001, t + dur);
        osc.connect(filter);
        filter.connect(g);
        g.connect(organGain);
        osc.start(); osc.stop(t + dur);

        // Quinte dar√ºber
        const o2 = audioCtx.createOscillator();
        const g2 = audioCtx.createGain();
        o2.type = 'sine'; o2.frequency.value = freq * 1.5;
        g2.gain.setValueAtTime(0, t);
        g2.gain.linearRampToValueAtTime(0.1, t + 0.5);
        g2.gain.exponentialRampToValueAtTime(0.001, t + dur);
        o2.connect(g2); g2.connect(organGain);
        o2.start(); o2.stop(t + dur);
    }

    const organNotes = [55, 58.27, 65.41, 73.42, 82.41, 87.31, 98, 110];
    function startOrgan() {
        if (organInterval) return;
        function next() {
            if (!G.started || G.gameOver) return;
            playOrganNote(organNotes[Math.floor(Math.random() * organNotes.length)], 2 + Math.random() * 4);
            organInterval = setTimeout(next, 2000 + Math.random() * 3000);
        }
        next();
    }
    function stopOrgan() { if (organInterval) { clearTimeout(organInterval); organInterval = null; } }

    // ‚îÄ‚îÄ‚îÄ üíì HERZSCHLAG (Monster-N√§he) ‚îÄ‚îÄ‚îÄ
    function playHeartbeat() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Lub
        const o1 = audioCtx.createOscillator(), g1 = audioCtx.createGain();
        o1.type = 'sine';
        o1.frequency.setValueAtTime(65, t);
        o1.frequency.exponentialRampToValueAtTime(30, t + 0.15);
        g1.gain.setValueAtTime(1.0, t);
        g1.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
        o1.connect(g1); g1.connect(heartGain);
        o1.start(t); o1.stop(t + 0.3);
        // Dub
        const o2 = audioCtx.createOscillator(), g2 = audioCtx.createGain();
        o2.type = 'sine';
        o2.frequency.setValueAtTime(55, t + 0.12);
        o2.frequency.exponentialRampToValueAtTime(25, t + 0.35);
        g2.gain.setValueAtTime(0, t);
        g2.gain.setValueAtTime(0.8, t + 0.12);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
        o2.connect(g2); g2.connect(heartGain);
        o2.start(t); o2.stop(t + 0.4);
    }

    function updateProximityHeart(distance) {
        if (!audioCtx || !heartGain) return;
        if (distance < PROXIMITY_DISTANCE) {
            const intensity = (1 - distance / 200) * 1.5;
            heartGain.gain.linearRampToValueAtTime(intensity, audioCtx.currentTime + 0.1);
            if (!proximityHeartActive) {
                proximityHeartActive = true;
                heartInterval = setInterval(playHeartbeat, 700);
                playHeartbeat();
            }
        } else {
            if (proximityHeartActive) {
                proximityHeartActive = false;
                heartGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                if (heartInterval) { clearInterval(heartInterval); heartInterval = null; }
            }
        }
    }

    // ‚îÄ‚îÄ‚îÄ üëª FL√úSTERNDE STIMMEN (Dark Pulse) ‚îÄ‚îÄ‚îÄ
    function playWhisper() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const dur = 0.5 + Math.random() * 1.5;

        // Noise-basierte Stimme durch schmalen Bandpass
        const bufSize = audioCtx.sampleRate * dur;
        const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < bufSize; i++) {
            // Moduliertes Rauschen mit Formanten
            const env = Math.sin(i / bufSize * Math.PI);
            const tremolo = 0.5 + 0.5 * Math.sin(i / audioCtx.sampleRate * (8 + Math.random() * 15) * Math.PI * 2);
            data[i] = (Math.random() * 2 - 1) * env * tremolo;
        }
        const src = audioCtx.createBufferSource();
        src.buffer = buf;

        // Bandpass-Filter f√ºr stimm√§hnlichen Klang
        const bp = audioCtx.createBiquadFilter();
        bp.type = 'bandpass';
        bp.frequency.value = 300 + Math.random() * 600;
        bp.Q.value = 5 + Math.random() * 10;

        // Zweiter Filter f√ºr mehr "Stimme"
        const bp2 = audioCtx.createBiquadFilter();
        bp2.type = 'bandpass';
        bp2.frequency.value = 1500 + Math.random() * 1500;
        bp2.Q.value = 3;

        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.4, t + 0.1);
        g.gain.setValueAtTime(0.3, t + dur * 0.5);
        g.gain.exponentialRampToValueAtTime(0.001, t + dur);

        // Stereo-Pan f√ºr r√§umlichen Effekt
        const pan = audioCtx.createStereoPanner();
        pan.pan.value = (Math.random() - 0.5) * 1.8;

        src.connect(bp);
        bp.connect(bp2);
        bp2.connect(g);
        g.connect(pan);
        pan.connect(whisperGain);
        src.start(t); src.stop(t + dur);

        // Gelegentlich tiefes St√∂hnen dazu
        if (Math.random() < 0.3) {
            const moan = audioCtx.createOscillator();
            const mg = audioCtx.createGain();
            moan.type = 'sawtooth';
            moan.frequency.setValueAtTime(80 + Math.random() * 40, t);
            moan.frequency.linearRampToValueAtTime(60 + Math.random() * 30, t + dur);
            const mf = audioCtx.createBiquadFilter();
            mf.type = 'lowpass'; mf.frequency.value = 200;
            mg.gain.setValueAtTime(0, t);
            mg.gain.linearRampToValueAtTime(0.15, t + 0.2);
            mg.gain.exponentialRampToValueAtTime(0.001, t + dur);
            moan.connect(mf); mf.connect(mg); mg.connect(whisperGain);
            moan.start(t); moan.stop(t + dur);
        }
    }

    function startWhispers() {
        if (whisperInterval) return;
        if (whisperGain) whisperGain.gain.linearRampToValueAtTime(0.5, audioCtx.currentTime + 0.3);
        playWhisper();
        whisperInterval = setInterval(playWhisper, 400 + Math.random() * 600);
    }

    function stopWhispers() {
        if (whisperInterval) { clearInterval(whisperInterval); whisperInterval = null; }
        if (whisperGain) whisperGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
    }

    // ‚îÄ‚îÄ‚îÄ ü©∏ BLUTSPUR SAMMEL-SOUNDS ‚îÄ‚îÄ‚îÄ
    function playBloodCollect() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        
        // 1. Tiefes Blut-Glucker (Hauptsound)
        const bubble = audioCtx.createOscillator();
        const bg = audioCtx.createGain();
        const bf = audioCtx.createBiquadFilter();
        bubble.type = 'sine';
        bubble.frequency.setValueAtTime(180, t);
        bubble.frequency.exponentialRampToValueAtTime(80, t + 0.3);
        bf.type = 'lowpass';
        bf.frequency.value = 400;
        bg.gain.setValueAtTime(0.4, t);
        bg.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        bubble.connect(bf);
        bf.connect(bg);
        bg.connect(masterGain);
        bubble.start(t);
        bubble.stop(t + 0.35);
        
        // 2. Hoher "Saug"-Ton
        const hiss = audioCtx.createOscillator();
        const hg = audioCtx.createGain();
        hiss.type = 'sawtooth';
        hiss.frequency.setValueAtTime(2000, t);
        hiss.frequency.exponentialRampToValueAtTime(500, t + 0.15);
        hg.gain.setValueAtTime(0.15, t);
        hg.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
        hiss.connect(hg);
        hg.connect(masterGain);
        hiss.start(t);
        hiss.stop(t + 0.2);
        
        // 3. Zufriedenheitston (tiefes Summen)
        const hum = audioCtx.createOscillator();
        const humg = audioCtx.createGain();
        hum.type = 'sine';
        hum.frequency.value = 110;
        humg.gain.setValueAtTime(0, t);
        humg.gain.linearRampToValueAtTime(0.3, t + 0.1);
        humg.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
        hum.connect(humg);
        humg.connect(masterGain);
        hum.start(t);
        hum.stop(t + 0.55);
    }

    // ‚îÄ‚îÄ‚îÄ üö™ TOR ERSCHEINT SOUND ‚îÄ‚îÄ‚îÄ
    function playGateAppearsSound() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        
        // 1. Mystisches √ñffnen
        const gate = audioCtx.createOscillator();
        const gg = audioCtx.createGain();
        gate.type = 'sine';
        gate.frequency.setValueAtTime(220, t);
        gate.frequency.exponentialRampToValueAtTime(880, t + 1.5);
        gg.gain.setValueAtTime(0, t);
        gg.gain.linearRampToValueAtTime(0.5, t + 0.3);
        gg.gain.exponentialRampToValueAtTime(0.001, t + 2);
        
        const gf = audioCtx.createBiquadFilter();
        gf.type = 'lowpass';
        gf.frequency.value = 1200;
        
        gate.connect(gf);
        gf.connect(gg);
        gg.connect(masterGain);
        gate.start(t);
        gate.stop(t + 2.1);
        
        // 2. Glockenklang
        for (let i = 0; i < 3; i++) {
            const bell = audioCtx.createOscillator();
            const bg = audioCtx.createGain();
            bell.type = 'sine';
            bell.frequency.value = 660 * (i + 1);
            bg.gain.setValueAtTime(0, t + i * 0.1);
            bg.gain.linearRampToValueAtTime(0.2, t + i * 0.1 + 0.05);
            bg.gain.exponentialRampToValueAtTime(0.001, t + i * 0.1 + 1);
            bell.connect(bg);
            bg.connect(masterGain);
            bell.start(t + i * 0.1);
            bell.stop(t + i * 0.1 + 1.1);
        }
    }

    // ‚îÄ‚îÄ‚îÄ ‚ö†Ô∏è FAKE SPUR SAMMEL-SOUND ‚îÄ‚îÄ‚îÄ
    function playFakeCollect() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        
        // 1. Disharmonischer "Fehler"-Ton
        const wrong = audioCtx.createOscillator();
        const wg = audioCtx.createGain();
        wrong.type = 'square';
        wrong.frequency.setValueAtTime(300, t);
        wrong.frequency.setValueAtTime(280, t + 0.1);
        wrong.frequency.setValueAtTime(310, t + 0.2);
        wrong.frequency.setValueAtTime(260, t + 0.3);
        wg.gain.setValueAtTime(0.3, t);
        wg.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
        wrong.connect(wg);
        wg.connect(masterGain);
        wrong.start(t);
        wrong.stop(t + 0.45);
        
        // 2. Hohes Piepsen (Warnung)
        const warn = audioCtx.createOscillator();
        const warg = audioCtx.createGain();
        warn.type = 'sine';
        warn.frequency.setValueAtTime(1500, t);
        warn.frequency.linearRampToValueAtTime(2000, t + 0.15);
        warg.gain.setValueAtTime(0.2, t);
        warg.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
        warn.connect(warg);
        warg.connect(masterGain);
        warn.start(t);
        warn.stop(t + 0.2);
        
        // 3. Tiefer "Nein"-Groll
        const growl = audioCtx.createOscillator();
        const growlg = audioCtx.createGain();
        growl.type = 'sawtooth';
        growl.frequency.setValueAtTime(100, t);
        growl.frequency.linearRampToValueAtTime(60, t + 0.3);
        const growlf = audioCtx.createBiquadFilter();
        growlf.type = 'lowpass';
        growlf.frequency.value = 200;
        growlg.gain.setValueAtTime(0.25, t);
        growlg.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
        growl.connect(growlf);
        growlf.connect(growlg);
        growlg.connect(masterGain);
        growl.start(t);
        growl.stop(t + 0.4);
    }

    // ‚îÄ‚îÄ‚îÄ üòá GEFALLENENER ENGEL JUMPSCARE ‚îÄ‚îÄ‚îÄ
    function playJumpscare() {
        if (!audioCtx) return;
        
        // VISUELLER JUMPSCARE - Gefallener Engel
        const jumpEl = document.getElementById('jumpscare');
        jumpEl.style.display = 'flex';
        jumpEl.classList.add('active');
        document.body.style.overflow = 'hidden';
        
        // Hektische Blitz-Sequenz: Dunkelheit ‚Üí Blutrot ‚Üí Wei√ü
        let flashes = 0;
        const flashInterval = setInterval(() => {
            const phase = flashes % 5;
            if (phase === 0) jumpEl.style.background = '#200000';
            else if (phase === 1) jumpEl.style.background = '#000';
            else if (phase === 2) jumpEl.style.background = '#ff0000';
            else if (phase === 3) jumpEl.style.background = '#000';
            else jumpEl.style.background = '#100000';
            flashes++;
            if (flashes > 15) {
                clearInterval(flashInterval);
                jumpEl.style.background = '#000';
            }
        }, 80);
        
        // Nach 2.5 Sekunden ausblenden
        setTimeout(() => {
            jumpEl.style.transition = 'opacity 0.5s';
            jumpEl.style.opacity = '0';
            setTimeout(() => {
                jumpEl.classList.remove('active');
                jumpEl.style.display = 'none';
                jumpEl.style.opacity = '1';
                jumpEl.style.transition = '';
            }, 500);
            document.body.style.overflow = '';
        }, 2500);
        
        const t = audioCtx.currentTime;

        // 1. HIMMLISCHER CHOR ‚Üí VERDAMMNIS
        // Beginnt als Engel, wird zu D√§mon
        const choirFreqs = [220, 277, 330, 440, 554, 659]; // Himmlisch
        const fallenFreqs = [110, 116.5, 130.8, 138.6, 155.6, 164.8]; // Verdammnis
        choirFreqs.forEach((f, i) => {
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.type = 'sine'; // Engel = Sine
            o.frequency.setValueAtTime(f, t);
            // Fallen: Frequenz sinkt, wird dissonant
            o.frequency.linearRampToValueAtTime(fallenFreqs[i], t + 0.5);
            o.type = 'sawtooth'; // Wird zu D√§mon
            g.gain.setValueAtTime(0.3, t);
            g.gain.setValueAtTime(0.5, t + 0.5);
            g.gain.exponentialRampToValueAtTime(0.001, t + 3);
            o.connect(g); g.connect(jumpscareGain);
            o.start(t); o.stop(t + 3.1);
        });

        // 2. ENGELSSCHREI (Himmel ‚Üí H√∂lle)
        const scream = audioCtx.createOscillator();
        const screamg = audioCtx.createGain();
        scream.type = 'sine';
        scream.frequency.setValueAtTime(880, t); // Hoher Engelston
        scream.frequency.exponentialRampToValueAtTime(110, t + 1); // F√§llt in die Tiefe
        scream.type = 'sawtooth'; // Wird rau
        screamg.gain.setValueAtTime(0.8, t);
        screamg.gain.exponentialRampToValueAtTime(0.001, t + 1.5);
        scream.connect(screamg);
        screamg.connect(jumpscareGain);
        scream.start(t);
        scream.stop(t + 1.6);

        // 3. FL√úGEL-GER√ÑUSCHE (Rauschen)
        for (let w = 0; w < 3; w++) {
            const bufSize = audioCtx.sampleRate * 0.8;
            const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
            const data = buf.getChannelData(0);
            for (let i = 0; i < bufSize; i++) {
                const env = Math.exp(-i / (audioCtx.sampleRate * 0.3));
                const flap = Math.sin(i / audioCtx.sampleRate * 30 * Math.PI * 2);
                data[i] = (Math.random() * 2 - 1) * env * (0.3 + flap * 0.7);
            }
            const src = audioCtx.createBufferSource();
            src.buffer = buf;
            const wg = audioCtx.createGain();
            wg.gain.value = 0.6;
            src.connect(wg);
            wg.connect(jumpscareGain);
            src.start(t + w * 0.2);
        }

        // 4. GLOCKE DES HIMMELS (Verdreckt)
        const bell = audioCtx.createOscillator();
        const bg = audioCtx.createGain();
        bell.type = 'sine';
        bell.frequency.setValueAtTime(880, t); // Hohe Glocke
        bell.frequency.exponentialRampToValueAtTime(55, t + 2); // Wird tief
        bg.gain.setValueAtTime(0.5, t);
        bg.gain.exponentialRampToValueAtTime(0.001, t + 2.5);
        bell.connect(bg);
        bg.connect(jumpscareGain);
        bell.start(t);
        bell.stop(t + 2.6);

        // 5. SUB-BASS: DER FALL
        const fall = audioCtx.createOscillator();
        const fallg = audioCtx.createGain();
        fall.type = 'sine';
        fall.frequency.setValueAtTime(200, t);
        fall.frequency.exponentialRampToValueAtTime(20, t + 1); // Tiefer Fall
        fallg.gain.setValueAtTime(1.0, t);
        fallg.gain.exponentialRampToValueAtTime(0.001, t + 1.5);
        fall.connect(fallg);
        fallg.connect(jumpscareGain);
        fall.start(t);
        fall.stop(t + 1.6);
    }

    function stopAllAudio() {
        stopOrgan(); stopWhispers();
        if (heartInterval) { clearInterval(heartInterval); heartInterval = null; }
        proximityHeartActive = false;
        if (heartGain) heartGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
        if (whisperGain) whisperGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
    }

    // ‚îÄ‚îÄ‚îÄ PARTICLES ‚îÄ‚îÄ‚îÄ
    function spawnParticles(x, y, color, count = 8) {
        for (let i = 0; i < count; i++) {
            const a = Math.random() * Math.PI * 2;
            const spd = 1 + Math.random() * 3;
            G.particles.push({
                x, y, vx: Math.cos(a) * spd, vy: Math.sin(a) * spd,
                life: 1, decay: 0.02 + Math.random() * 0.03,
                size: 2 + Math.random() * 4, color
            });
        }
    }

    function updateParticles() {
        for (let i = G.particles.length - 1; i >= 0; i--) {
            const p = G.particles[i];
            p.x += p.vx; p.y += p.vy;
            p.life -= p.decay;
            if (p.life <= 0) G.particles.splice(i, 1);
        }
    }

    function renderParticles() {
        G.particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, TWO_PI);
            ctx.fill();
        });
        ctx.globalAlpha = 1;
    }

    // ‚îÄ‚îÄ‚îÄ SCREEN SHAKE ‚îÄ‚îÄ‚îÄ
    function shake(intensity = 5, duration = 200) {
        G.shakeDur = duration;
        G.shakeIntensity = intensity;
    }

    // ‚îÄ‚îÄ‚îÄ TOAST (temporary message) ‚îÄ‚îÄ‚îÄ
    function showToast(text, color = '#ff6600', duration = 1500) {
        const el = document.getElementById('toast');
        el.innerHTML = text;
        el.style.color = color;
        el.style.textShadow = `0 0 15px ${color}`;
        el.style.opacity = 1;
        G.toastTimer = duration;
    }

    function showMessage(text, color = '#ff0000') {
        const el = document.getElementById('message');
        el.innerHTML = text;
        el.style.color = color;
        el.style.textShadow = `0 0 30px ${color}`;
        el.style.display = 'block';
        el.style.opacity = 1;
    }

    // ‚îÄ‚îÄ‚îÄ INIT ‚îÄ‚îÄ‚îÄ
    function init() {
        G.found = 0;
        G.gameOver = false;
        G.won = false;
        G.particles = [];
        G.shakeDur = 0;
        G.toastTimer = 0;

        const now = Date.now();
        G.teleportTimer = now;
        G.teleportFlash = 0;
        G.lightsOutTimer = now;
        G.lightsOutPhase = 'none';
        G.darkPulseTimer = now;
        G.darkPulseActive = false;
        G.startTime = now;

        // Reset gate
        G.gate.active = false;
        G.gate.x = 0;
        G.gate.y = 0;

        // Player center
        G.player.x = canvas.width / 2;
        G.player.y = canvas.height / 2;
        G.player.angle = 0;

        // Spawn real tracks (9-12) in clusters
        G.tracks = [];
        const total = 14 + Math.floor(Math.random() * 5);
        let created = 0;

        while (created < total) {
            const cx = 80 + Math.random() * (canvas.width - 160);
            const cy = 80 + Math.random() * (canvas.height - 160);
            if (Math.hypot(cx - G.player.x, cy - G.player.y) < TRACK_SPAWN_MIN_DISTANCE) continue;

            const cluster = Math.random() < 0.6 ? (Math.random() < 0.5 ? 2 : 3) : 1;
            const actual = Math.min(cluster, total - created);

            for (let i = 0; i < actual; i++) {
                const a = Math.random() * Math.PI * 2;
                const d = i === 0 ? 0 : 20 + Math.random() * 35;
                const sizeMul = [0.6, 1, 1, 1.3][Math.floor(Math.random() * 4)];
                G.tracks.push({
                    x: cx + Math.cos(a) * d,
                    y: cy + Math.sin(a) * d,
                    size: (12 + Math.random() * 18) * sizeMul,
                    shade: Math.random(), // 0=dark, 1=bright
                    isFake: false,
                    found: false
                });
                created++;
            }
        }
        G.total = created;

        // Fake tracks from monster (3-5)
        const fakes = 3 + Math.floor(Math.random() * 3);
        for (let i = 0; i < fakes; i++) {
            let fx, fy;
            do {
                fx = 60 + Math.random() * (canvas.width - 120);
                fy = 60 + Math.random() * (canvas.height - 120);
            } while (Math.hypot(fx - G.player.x, fy - G.player.y) < FAKE_TRACK_SPAWN_MIN_DISTANCE);
            G.tracks.push({
                x: fx, y: fy,
                size: 10 + Math.random() * 16,
                shade: Math.random(),
                isFake: true,
                found: false
            });
        }

        // Monster far from player
        do {
            G.monster.x = Math.random() * canvas.width;
            G.monster.y = Math.random() * canvas.height;
        } while (Math.hypot(G.monster.x - G.player.x, G.monster.y - G.player.y) < SPAWN_MIN_DISTANCE);

        document.getElementById('score').textContent = '0';
        document.getElementById('total').textContent = G.total;
        document.getElementById('remaining').textContent = G.total;
        document.getElementById('message').style.display = 'none';
        document.getElementById('toast').style.opacity = 0;
        if (audioStarted) { stopAllAudio(); startOrgan(); }
    }

    // ‚îÄ‚îÄ‚îÄ INPUT ‚îÄ‚îÄ‚îÄ
    const keys = {};
    document.addEventListener('keydown', e => {
        keys[e.key.toLowerCase()] = true;
        if (e.key.toLowerCase() === 'r' && G.gameOver) init();
    });
    document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    // ‚îÄ‚îÄ‚îÄ UPDATE ‚îÄ‚îÄ‚îÄ
    function update(dt) {
        if (G.gameOver) return;
        const now = Date.now();

        // Toast fade
        if (G.toastTimer > 0) {
            G.toastTimer -= dt;
            if (G.toastTimer <= 0) {
                document.getElementById('toast').style.opacity = 0;
            }
        }

        // Screen shake
        if (G.shakeDur > 0) {
            G.shakeDur -= dt;
            G.shakeX = (Math.random() - 0.5) * G.shakeIntensity * 2;
            G.shakeY = (Math.random() - 0.5) * G.shakeIntensity * 2;
        } else {
            G.shakeX = 0; G.shakeY = 0;
        }

        // Player movement
        let dx = 0, dy = 0;
        if (keys['w'] || keys['arrowup']) dy = -1;
        if (keys['s'] || keys['arrowdown']) dy = 1;
        if (keys['a'] || keys['arrowleft']) dx = -1;
        if (keys['d'] || keys['arrowright']) dx = 1;

        const speedMod = G.darkPulseActive ? 0.65 : 1;
        if (dx !== 0 || dy !== 0) {
            const len = Math.hypot(dx, dy);
            dx /= len; dy /= len;
            G.player.x = Math.max(15, Math.min(canvas.width - 15, G.player.x + dx * G.player.speed * speedMod));
            G.player.y = Math.max(15, Math.min(canvas.height - 15, G.player.y + dy * G.player.speed * speedMod));
            G.player.angle = Math.atan2(dy, dx);
        }

        // Monster chase
        const mx = G.player.x - G.monster.x;
        const my = G.player.y - G.monster.y;
        const md = Math.hypot(mx, my);
        const monsterMod = G.darkPulseActive ? 2.0 : 1;
        if (md > 0) {
            G.monster.x += (mx / md) * G.monster.speed * monsterMod;
            G.monster.y += (my / md) * G.monster.speed * monsterMod;
        }

        // ‚îÄ‚îÄ ABILITY: Divine Prediction (teleport in front of player every 8s) ‚îÄ‚îÄ
        if (now - G.teleportTimer > G.teleportCooldown) {
            const dist = G.flashRadius * 0.8;
            G.monster.x = Math.max(30, Math.min(canvas.width - 30,
                G.player.x + Math.cos(G.player.angle) * dist));
            G.monster.y = Math.max(30, Math.min(canvas.height - 30,
                G.player.y + Math.sin(G.player.angle) * dist));
            G.teleportTimer = now;
            G.teleportFlash = 800;
        }
        if (G.teleportFlash > 0) G.teleportFlash -= dt;

        // ‚îÄ‚îÄ ABILITY: Lights Out (every 13s: 3s flicker + 2s dark) ‚îÄ‚îÄ
        if (G.lightsOutPhase === 'none' && now - G.lightsOutTimer > LIGHTS_OUT_INTERVAL) {
            G.lightsOutPhase = 'flicker';
            G.lightsOutStart = now;
        }
        if (G.lightsOutPhase === 'flicker' && now - G.lightsOutStart > 3000) {
            G.lightsOutPhase = 'dark';
            G.lightsOutStart = now;
            shake(4, 500);
        }
        if (G.lightsOutPhase === 'dark' && now - G.lightsOutStart > 2000) {
            G.lightsOutPhase = 'none';
            G.lightsOutTimer = now;
        }

        // ‚îÄ‚îÄ ABILITY: Dark Pulse Realm (every 20s for 4s) ‚îÄ‚îÄ
        if (!G.darkPulseActive && now - G.darkPulseTimer > DARK_PULSE_INTERVAL) {
            G.darkPulseActive = true;
            G.darkPulseTimer = now;
            shake(6, 400);
            startWhispers();
        }
        if (G.darkPulseActive && now - G.darkPulseTimer > DARK_PULSE_DURATION) {
            G.darkPulseActive = false;
            G.darkPulseTimer = now;
            stopWhispers();
        }

        // Catch player
        // Herzschlag basierend auf Monster-N√§he
        updateProximityHeart(md);

        if (md < CATCH_DISTANCE) {
            G.gameOver = true;
            G.won = false;
            shake(15, 500);
            stopAllAudio();
            playJumpscare();
            showMessage('üíÄ DU WURDEST ERWISCHT!<br><small>R = Neustart</small>');
        }

        // Check Gate collision (Sieg wenn Spieler das Tor erreicht)
        if (G.gate.active) {
            const gateDist = Math.hypot(G.player.x - G.gate.x, G.player.y - G.gate.y);
            if (gateDist < G.gate.radius) {
                G.gameOver = true;
                G.won = true;
                const secs = Math.floor((Date.now() - G.startTime) / 1000);
                stopAllAudio();
                showMessage(`üèÜ ENTKOMMEN DURCH DAS TOR!<br><small>${secs}s ‚Äî R = Neustart</small>`, '#00ff00');
            }
        }

        // Collect tracks
        G.tracks.forEach(track => {
            if (track.found) return;
            const d = Math.hypot(track.x - G.player.x, track.y - G.player.y);
            if (d > COLLECT_DISTANCE) return;

            // Must be in flashlight cone
            const a = Math.atan2(track.y - G.player.y, track.x - G.player.x);
            let diff = a - G.player.angle;
            while (diff > Math.PI) diff -= TWO_PI;
            while (diff < -Math.PI) diff += TWO_PI;
            if (Math.abs(diff) > G.flashCone / 2) return;

            track.found = true;

            if (track.isFake) {
                // Fake! Subtract point + warning + spawn new real track
                G.found = Math.max(0, G.found - 1);
                shake(6, 250);
                spawnParticles(track.x, track.y, '#00ff00', 12);
                showToast('‚ö†Ô∏è FALSCHE SPUR! -1', '#ff6600', 1500);
                playFakeCollect(); // Warn-Sound
                
                // Neue echte Blutspur spawnen (garantiert genug Spuren zum Gewinnen)
                let newX, newY, attempts = 0;
                do {
                    newX = 60 + Math.random() * (canvas.width - 120);
                    newY = 60 + Math.random() * (canvas.height - 120);
                    attempts++;
                } while (
                    (Math.hypot(newX - G.player.x, newY - G.player.y) < 100 ||
                     Math.hypot(newX - G.monster.x, newY - G.monster.y) < 80) &&
                    attempts < 30
                );
                
                if (attempts < 30) {
                    G.tracks.push({
                        x: newX, y: newY,
                        size: 12 + Math.random() * 16,
                        shade: Math.random(),
                        isFake: false,
                        found: false
                    });
                    // NICHT G.total erh√∂hen - die neue Spur ist Ersatz
                }
            } else {
                // Real track
                G.found++;
                spawnParticles(track.x, track.y, '#ff0000', 10);
                playBloodCollect(); // Blut-Sammel-Sound
            }
            
            // Score und Verbleibend aktualisieren
            document.getElementById('score').textContent = G.found;
            const remaining = G.tracks.filter(t => !t.found && !t.isFake).length;
            document.getElementById('remaining').textContent = remaining;

            // Tor erscheint wenn: alle gefunden ODER keine echten mehr da
            if ((G.found >= G.total || remaining === 0) && !G.gate.active) {
                G.gate.active = true;
                // Tor an zuf√§lliger Position spawnen (nicht zu nah am Monster oder Spieler)
                let gateX, gateY;
                let attempts = 0;
                do {
                    gateX = 100 + Math.random() * (canvas.width - 200);
                    gateY = 100 + Math.random() * (canvas.height - 200);
                    attempts++;
                } while ((Math.hypot(gateX - G.player.x, gateY - G.player.y) < 200 ||
                         Math.hypot(gateX - G.monster.x, gateY - G.monster.y) < 300) &&
                            attempts < 50);
                    G.gate.x = gateX;
                    G.gate.y = gateY;
                    shake(8, 600);
                    showToast('üö™ DAS TOR IST OFFEN! FLIEHE!', '#ff00ff', 3000);
                    playGateAppearsSound();
                }
        });

        updateParticles();
    }

    // ‚îÄ‚îÄ‚îÄ RENDER ‚îÄ‚îÄ‚îÄ
    function render() {
        ctx.save();
        ctx.translate(G.shakeX, G.shakeY);

        // Clear
        ctx.fillStyle = '#050505';
        ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);

        // ‚îÄ‚îÄ Draw blood tracks ‚îÄ‚îÄ
        G.tracks.forEach(track => {
            if (track.found) return;
            const d = Math.hypot(track.x - G.player.x, track.y - G.player.y);
            if (d > G.flashRadius) return;

            const s = track.shade;
            const r = Math.floor(100 + s * 120);
            const g = Math.floor(20 + s * 20);
            const b = Math.floor(20 + s * 15);
            const alpha = (1 - d / G.flashRadius) * (0.5 + s * 0.5);

            // Blood puddle - runder aber leicht unregelm√§√üig
            ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
            ctx.beginPath();
            const steps = 12;
            for (let i = 0; i < steps; i++) {
                const angle = (i / steps) * Math.PI * 2;
                const wobble = 0.85 + Math.sin(i * 1.8 + track.x * 0.1) * 0.15;
                const px = track.x + Math.cos(angle) * track.size * wobble;
                const py = track.y + Math.sin(angle) * track.size * wobble;
                i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();

            // Fake tracks: gr√ºne Umrandung
            if (track.isFake) {
                ctx.strokeStyle = `rgba(0, 200, 0, ${alpha * 0.7})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        });

        // ‚îÄ‚îÄ Draw monster (Celestial) ‚îÄ‚îÄ
        const t = Date.now() / 1000;
        const mx = G.monster.x, my = G.monster.y;

        // Wings (dark, barely visible)
        ctx.fillStyle = '#080808';
        ctx.strokeStyle = '#151515';
        ctx.lineWidth = 1.5;
        for (let i = 0; i < 4; i++) {
            const flap = Math.sin(t * 3 + i * 0.5) * (10 + i * 3);
            const lwx = mx - 38 - flap, lwy = my - 18 + i * 22;
            const rwx = mx + 38 + flap, rwy = my - 18 + i * 22;
            ctx.beginPath();
            ctx.ellipse(lwx, lwy, 28, 10, -0.2, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(rwx, rwy, 28, 10, 0.2, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();

            // üëÅÔ∏è 4 Augen pro Fl√ºgel, am oberen Rand
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 10;
            for (let e = 0; e < 4; e++) {
                const eyeOffset = -20 + e * 13;
                const eyeGlow = 0.4 + Math.sin(t * 3 + i * 1.5 + e * 0.8) * 0.4;
                const eyeSize = 1.8 + Math.sin(t * 2 + e) * 0.4;
                ctx.fillStyle = `rgba(255, 255, 255, ${eyeGlow})`;
                // Linker Fl√ºgel - Augen oben
                ctx.beginPath();
                ctx.arc(lwx + eyeOffset, lwy - 6, eyeSize, 0, Math.PI * 2);
                ctx.fill();
                // Rechter Fl√ºgel - Augen oben
                ctx.beginPath();
                ctx.arc(rwx + eyeOffset, rwy - 6, eyeSize, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#080808';
        }

        // Face wings
        ctx.fillStyle = '#060606';
        const fw = Math.sin(t * 2.5) * 7;
        ctx.beginPath();
        ctx.ellipse(mx - 18, my - 8, 16, 20, -0.3, 0, Math.PI * 2);
        ctx.fill(); ctx.stroke();
        ctx.beginPath();
        ctx.ellipse(mx + 18, my - 8, 16, 20, 0.3, 0, Math.PI * 2);
        ctx.fill(); ctx.stroke();

        // Body
        const wb = Math.sin(t * 3) * 2;
        ctx.beginPath();
        ctx.ellipse(mx, my + 18, 14 + wb, 16 - wb, 0, 0, Math.PI * 2);
        ctx.fillStyle = '#040404';
        ctx.fill(); ctx.stroke();

        // Halo
        ctx.beginPath();
        ctx.arc(mx, my - 42, 11, 0, Math.PI * 2);
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 2.5;
        ctx.stroke();

        // Eyes (red, always visible ‚Äî the scary part)
        const ea = Math.atan2(G.player.y - my, G.player.x - mx);
        const eyeGlow = 0.6 + Math.sin(t * 4) * 0.4;
        ctx.fillStyle = `rgba(255, 255, 255, ${eyeGlow})`;
        ctx.shadowColor = '#ffffff';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(mx + Math.cos(ea + 0.2) * 5, my + Math.sin(ea + 0.2) * 5 - 4, 3.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(mx + Math.cos(ea - 0.2) * 5, my + Math.sin(ea - 0.2) * 5 - 4, 3.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // ‚îÄ‚îÄ Flashlight / darkness mask ‚îÄ‚îÄ
        let lightR = G.flashRadius;
        let flicker = 1;

        if (G.lightsOutPhase === 'flicker') {
            flicker = 0.2 + Math.random() * 0.8;
            lightR = G.flashRadius * (0.4 + Math.random() * 0.6);
        } else if (G.lightsOutPhase === 'dark') {
            flicker = 0;
        }

        if (flicker > 0) {
            // Flashlight cone mask
            ctx.save();
            ctx.globalCompositeOperation = 'destination-in';
            ctx.beginPath();
            ctx.moveTo(G.player.x, G.player.y);
            ctx.arc(G.player.x, G.player.y, lightR,
                G.player.angle - G.flashCone / 2,
                G.player.angle + G.flashCone / 2);
            ctx.closePath();
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.restore();

            // Flashlight glow
            ctx.save();
            ctx.globalAlpha = 0.12 * flicker;
            ctx.beginPath();
            ctx.moveTo(G.player.x, G.player.y);
            ctx.arc(G.player.x, G.player.y, lightR,
                G.player.angle - G.flashCone / 2,
                G.player.angle + G.flashCone / 2);
            ctx.closePath();
            ctx.fillStyle = '#ffff88';
            ctx.fill();
            ctx.restore();
        } else {
            // Total darkness ‚Äî only tiny glow around player
            ctx.save();
            ctx.globalCompositeOperation = 'destination-in';
            ctx.beginPath();
            ctx.arc(G.player.x, G.player.y, 3, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.restore();
        }

        // ‚îÄ‚îÄ Player (always visible) ‚îÄ‚îÄ
        ctx.globalCompositeOperation = 'source-over';
        ctx.beginPath();
        ctx.arc(G.player.x, G.player.y, 11, 0, Math.PI * 2);
        ctx.fillStyle = '#ffcc99';
        ctx.fill();
        ctx.strokeStyle = '#c49070';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Small glow around player
        const pglow = ctx.createRadialGradient(G.player.x, G.player.y, 0, G.player.x, G.player.y, 30);
        pglow.addColorStop(0, 'rgba(255,200,150,0.08)');
        pglow.addColorStop(1, 'transparent');
        ctx.fillStyle = pglow;
        ctx.fillRect(G.player.x - 30, G.player.y - 30, 60, 60);

        // ‚îÄ‚îÄ Particles ‚îÄ‚îÄ
        renderParticles();

        // ‚îÄ‚îÄ Exit Gate ‚îÄ‚îÄ
        if (G.gate.active) {
            const time = Date.now() / 1000;
            const gx = G.gate.x, gy = G.gate.y;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            
            // √Ñu√üerer Gl√ºhring (pulsierend)
            const outerRadius = G.gate.radius + 20 + Math.sin(time * 3) * 10;
            const outerGlow = ctx.createRadialGradient(gx, gy, G.gate.radius, gx, gy, outerRadius);
            outerGlow.addColorStop(0, 'rgba(100, 0, 200, 0.4)');
            outerGlow.addColorStop(0.5, 'rgba(150, 0, 255, 0.2)');
            outerGlow.addColorStop(1, 'transparent');
            ctx.fillStyle = outerGlow;
            ctx.beginPath();
            ctx.arc(gx, gy, outerRadius, 0, TWO_PI);
            ctx.fill();
            
            // Innerer starker Gl√ºhring
            const innerGlow = ctx.createRadialGradient(gx, gy, 10, gx, gy, G.gate.radius);
            innerGlow.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            innerGlow.addColorStop(0.2, 'rgba(200, 100, 255, 0.8)');
            innerGlow.addColorStop(0.5, 'rgba(150, 0, 200, 0.5)');
            innerGlow.addColorStop(1, 'rgba(80, 0, 150, 0.2)');
            ctx.fillStyle = innerGlow;
            ctx.beginPath();
            ctx.arc(gx, gy, G.gate.radius, 0, TWO_PI);
            ctx.fill();
            
            // Drehende Tor-Struktur (8 Linien)
            ctx.strokeStyle = `rgba(255, 200, 255, ${0.6 + Math.sin(time * 5) * 0.3})`;
            ctx.lineWidth = 3;
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * TWO_PI + time * 2;
                const r1 = 20 + Math.sin(time * 4 + i) * 5;
                const r2 = G.gate.radius - 10;
                ctx.beginPath();
                ctx.moveTo(gx + Math.cos(angle) * r1, gy + Math.sin(angle) * r1);
                ctx.lineTo(gx + Math.cos(angle) * r2, gy + Math.sin(angle) * r2);
                ctx.stroke();
            }
            
            // Zentrales Symbol (stilisiertes Portal)
            ctx.fillStyle = `rgba(255, 255, 255, ${0.8 + Math.sin(time * 8) * 0.2})`;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * TWO_PI + time;
                const r = 15 + Math.sin(time * 6 + i * 2) * 5;
                const px = gx + Math.cos(angle) * r;
                const py = gy + Math.sin(angle) * r;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            
            // "TOR" Text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 16px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = '#ff00ff';
            ctx.shadowBlur = 15;
            ctx.fillText('TOR', gx, gy - 35);
            ctx.shadowBlur = 0;
            
            // Anzeige-Richtungspfeil wenn weit weg
            const distToGate = Math.hypot(G.player.x - gx, G.player.y - gy);
            if (distToGate > 200) {
                ctx.strokeStyle = 'rgba(255, 0, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(gx, gy, Math.min(distToGate / 2, 100), 0, TWO_PI);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            ctx.restore();
        }

        // ‚îÄ‚îÄ Edge effects ‚îÄ‚îÄ
        const distM = Math.hypot(G.monster.x - G.player.x, G.monster.y - G.player.y);
        let danger = 0;
        if (distM < PROXIMITY_DISTANCE && !G.gameOver) danger = Math.max(danger, (1 - distM / PROXIMITY_DISTANCE) * 0.5);
        if (G.teleportFlash > 0) danger = Math.max(danger, (G.teleportFlash / 800) * 0.7);

        // Dark Pulse Realm - INTENSIVIERTE Effekte
        if (G.darkPulseActive) {
            const time = Date.now();
            
            // 1. DUNKLES LILA OVERLAY (pulsierend)
            const pulseAlpha = 0.5 + Math.sin(time / 150) * 0.2;
            ctx.fillStyle = `rgba(60, 0, 80, ${pulseAlpha})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 2. RAND-PARTIKEL
            if (Math.random() < 0.4) {
                const side = Math.floor(Math.random() * 4);
                const px = side < 2 ? Math.random() * canvas.width : (side === 2 ? 0 : canvas.width);
                const py = side >= 2 ? Math.random() * canvas.height : (side === 0 ? 0 : canvas.height);
                const colors = ['#8800ff', '#4400aa', '#660088'];
                spawnParticles(px, py, colors[Math.floor(Math.random() * colors.length)], 2 + Math.floor(Math.random() * 3));
            }
            
            // 3. ORGANISCHE RANKEN - Variierend und nat√ºrlich
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const ts = time / 1000;
            const w = canvas.width, h = canvas.height;
            
            function drawOrganicVine(startX, startY, dirX, dirY, baseLength, seed, thickness) {
                const segments = 8 + Math.floor(Math.abs(Math.sin(seed * 7.3)) * 8);
                const curveFreq1 = 0.5 + Math.abs(Math.sin(seed * 3.1)) * 1.5;
                const curveFreq2 = 0.8 + Math.abs(Math.sin(seed * 4.7)) * 2.2;
                const curveAmp1 = 15 + Math.abs(Math.sin(seed * 2.9)) * 25;
                const curveAmp2 = 8 + Math.abs(Math.sin(seed * 5.3)) * 15;
                const length = baseLength * (0.7 + Math.abs(Math.sin(seed * 1.8)) * 0.6);
                const speed1 = 0.3 + Math.abs(Math.sin(seed * 6.2)) * 0.7;
                const speed2 = 0.4 + Math.abs(Math.sin(seed * 3.8)) * 0.8;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                let cx = startX, cy = startY, prevX = startX, prevY = startY;
                
                for (let i = 1; i <= segments; i++) {
                    const t = i / segments;
                    const wave1 = Math.sin(ts * speed1 + seed + t * curveFreq1 * 3) * curveAmp1 * (1 - t * 0.3);
                    const wave2 = Math.cos(ts * speed2 + seed * 2.1 + t * curveFreq2 * 4) * curveAmp2 * (1 - t * 0.5);
                    const wave3 = Math.sin(ts * 0.6 + seed * 3.7 + t * 7) * 8 * (1 - t);
                    
                    const perpX = -dirY, perpY = dirX;
                    cx += dirX * (length / segments);
                    cy += dirY * (length / segments);
                    
                    const organicX = cx + perpX * (wave1 + wave2 + wave3);
                    const organicY = cy + perpY * (wave1 + wave2 + wave3);
                    
                    const cpX = (prevX + organicX) / 2 + perpX * Math.sin(ts + seed + i) * 5;
                    const cpY = (prevY + organicY) / 2 + perpY * Math.sin(ts + seed + i) * 5;
                    
                    ctx.quadraticCurveTo(cpX, cpY, organicX, organicY);
                    prevX = organicX; prevY = organicY;
                }
                
                const hue = 260 + Math.sin(seed * 8.5) * 30;
                const alpha = 0.15 + Math.abs(Math.sin(ts * 0.4 + seed)) * 0.15;
                ctx.strokeStyle = `hsla(${hue}, 80%, 40%, ${alpha})`;
                ctx.lineWidth = thickness * (0.6 + Math.abs(Math.sin(ts * 0.3 + seed)) * 0.8);
                ctx.lineCap = 'round';
                ctx.stroke();
                
                if (Math.abs(Math.sin(seed * 9.7)) > 0.6 && length > 80) {
                    const branchPoint = 0.3 + Math.abs(Math.sin(seed * 2.4)) * 0.4;
                    const bx = startX + dirX * length * branchPoint;
                    const by = startY + dirY * length * branchPoint;
                    const branchDirX = dirX * Math.cos(0.8) - dirY * Math.sin(0.8) * (Math.sin(seed * 5.5) > 0 ? 1 : -1);
                    const branchDirY = dirX * Math.sin(0.8) + dirY * Math.cos(0.8) * (Math.sin(seed * 5.5) > 0 ? 1 : -1);
                    drawOrganicVine(bx, by, branchDirX, branchDirY, length * 0.5, seed * 1.5, thickness * 0.6);
                }
            }
            
            const leftCount = 5 + Math.floor(Math.abs(Math.sin(ts * 0.1)) * 4);
            const rightCount = 5 + Math.floor(Math.abs(Math.sin(ts * 0.12 + 1)) * 4);
            const topCount = 4 + Math.floor(Math.abs(Math.sin(ts * 0.08 + 2)) * 3);
            const bottomCount = 4 + Math.floor(Math.abs(Math.sin(ts * 0.11 + 3)) * 3);
            
            for (let v = 0; v < leftCount; v++) {
                const yPos = h * (0.08 + v * (0.85 / leftCount)) + Math.sin(ts * 0.2 + v * 2) * 30;
                const thickness = 1.5 + Math.abs(Math.sin(v * 3.3)) * 2.5;
                drawOrganicVine(0, yPos, 1, Math.sin(ts * 0.15 + v) * 0.15, h * 0.22, v * 1.7 + ts, thickness);
            }
            
            for (let v = 0; v < rightCount; v++) {
                const yPos = h * (0.05 + v * (0.9 / rightCount)) + Math.cos(ts * 0.25 + v * 1.5) * 35;
                const thickness = 1.5 + Math.abs(Math.sin(v * 4.1 + 10)) * 2.5;
                drawOrganicVine(w, yPos, -1, Math.cos(ts * 0.18 + v + 5) * 0.12, h * 0.25, v * 2.3 + ts + 100, thickness);
            }
            
            for (let v = 0; v < topCount; v++) {
                const xPos = w * (0.1 + v * (0.8 / topCount)) + Math.sin(ts * 0.22 + v * 2.2) * 40;
                const thickness = 1.5 + Math.abs(Math.sin(v * 3.9 + 20)) * 2;
                drawOrganicVine(xPos, 0, Math.sin(ts * 0.12 + v + 3) * 0.1, 1, w * 0.18, v * 1.9 + ts + 200, thickness);
            }
            
            for (let v = 0; v < bottomCount; v++) {
                const xPos = w * (0.12 + v * (0.76 / bottomCount)) + Math.cos(ts * 0.19 + v * 1.8) * 35;
                const thickness = 1.5 + Math.abs(Math.sin(v * 4.7 + 30)) * 2;
                drawOrganicVine(xPos, h, Math.cos(ts * 0.14 + v + 7) * 0.08, -1, w * 0.18, v * 2.1 + ts + 300, thickness);
            }
            
            ctx.restore();
            
            // 6. RAND-NEBEL (subtiler Dunst)
            ctx.save();
            for (let side = 0; side < 4; side++) {
                let fog;
                if (side === 0) { fog = ctx.createLinearGradient(0, 0, 0, h * 0.15); ctx.fillStyle = fog; }
                else if (side === 1) { fog = ctx.createLinearGradient(0, h, 0, h * 0.85); ctx.fillStyle = fog; }
                else if (side === 2) { fog = ctx.createLinearGradient(0, 0, w * 0.12, 0); ctx.fillStyle = fog; }
                else { fog = ctx.createLinearGradient(w, 0, w * 0.88, 0); ctx.fillStyle = fog; }
                const fogAlpha = 0.2 + Math.sin(time / (300 + side * 50) + side) * 0.1;
                fog.addColorStop(0, `rgba(80, 0, 120, ${fogAlpha})`);
                fog.addColorStop(1, 'transparent');
                ctx.fillStyle = fog;
                if (side === 0) ctx.fillRect(0, 0, w, h * 0.15);
                else if (side === 1) ctx.fillRect(0, h * 0.85, w, h * 0.15);
                else if (side === 2) ctx.fillRect(0, 0, w * 0.12, h);
                else ctx.fillRect(w * 0.88, 0, w * 0.12, h);
            }
            ctx.restore();
            
            // 7. VERST√ÑRKTES TASCHENLAMPPEN-FLACKERN
            G.flashRadius = FLASH_RADIUS - 30 - Math.random() * 60;
        } else {
            G.flashRadius = FLASH_RADIUS;
        }

        // Red danger vignette
        if (danger > 0) {
            const vg = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, canvas.height * 0.25,
                canvas.width / 2, canvas.height / 2, canvas.height * 0.75);
            vg.addColorStop(0, 'transparent');
            vg.addColorStop(1, `rgba(255,0,0,${danger})`);
            ctx.fillStyle = vg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        ctx.restore(); // end shake

        // ‚îÄ‚îÄ HUD updates ‚îÄ‚îÄ
        const elapsed = Math.floor((Date.now() - G.startTime) / 1000);
        document.getElementById('timer').textContent = `Zeit: ${elapsed}s`;

        // abilities removed
    }

    // ‚îÄ‚îÄ‚îÄ GAME LOOP ‚îÄ‚îÄ‚îÄ
    let lastTime = 0;
    function loop(time) {
        const dt = Math.min(time - lastTime, 50); // cap at 50ms
        lastTime = time;
        if (G.started) {
            update(dt);
            render();
        }
        requestAnimationFrame(loop);
    }

    function startGame() {
        document.getElementById('startscreen').style.display = 'none';
        G.started = true;
        initAudio();
        init();
    }

    requestAnimationFrame(loop);
    </script>
</body>
</html>
