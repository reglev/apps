<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Das Letzte Signal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #0f0;
        }
        #gameCanvas {
            display: block;
            background: #111;
        }
        #phoneIcon {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #0f0;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            color: #0f0;
            transition: transform 0.1s;
            z-index: 1000;
        }
        #phoneIcon:hover {
            transform: scale(1.1);
        }
        #phoneOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        #phoneInterface {
            width: 95%;
            max-width: 450px;
            height: 90%;
            background: #111;
            border: 2px solid #0f0;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            padding: 15px;
            box-shadow: 0 0 30px rgba(0,255,0,0.4);
            position: relative;
        }
        #phoneHeader {
            font-size: 18px;
            color: #0f0;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #0f0;
            margin-bottom: 10px;
        }
        #messageList {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            background: #000;
            border: 1px solid #333;
            margin-bottom: 10px;
            font-size: 14px;
        }
        .message {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 5px;
            max-width: 90%;
        }
        .message.sent {
            background: #0f0;
            color: #000;
            margin-left: auto;
            text-align: right;
        }
        .message.received {
            background: #222;
            color: #0f0;
            margin-right: auto;
            text-align: left;
            border: 1px solid #0f0;
        }
        .message .sender {
            font-size: 11px;
            margin-bottom: 3px;
            opacity: 0.7;
        }
        #inputArea {
            display: flex;
            gap: 5px;
        }
        #messageInput {
            flex: 1;
            background: #222;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border-radius: 5px;
        }
        #messageInput::placeholder {
            color: #666;
        }
        #sendButton {
            background: #0f0;
            color: #000;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        #closePhone {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: 1px solid #f00;
            color: #f00;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 14px;
        }
        .typing {
            font-style: italic;
            opacity: 0.6;
            padding: 5px;
        }

        /* Inventory UI */
        #inventoryBar {
            position: absolute;
            bottom: 90px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 999;
        }
        .invSlot {
            width: 50px;
            height: 50px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #0f0;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            position: relative;
        }
        .invSlot.active {
            border-color: #ff0;
            box-shadow: 0 0 10px #ff0;
        }
        .invSlot .count {
            position: absolute;
            bottom: 2px;
            right: 5px;
            font-size: 12px;
            color: #0f0;
        }

        /* Instructions overlay */
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #0f0;
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            font-size: 13px;
            z-index: 999;
            color: #0f0;
        }
        #instructions h3 {
            margin-bottom: 8px;
            font-size: 16px;
        }
        #instructions ul {
            list-style: none;
            padding-left: 0;
        }
        #instructions li {
            margin-bottom: 5px;
        }
        #instructions .key {
            background: #222;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #444;
            font-family: monospace;
        }

        /* HUD - danger indicator (now just generic) */
        #statusBar {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #0f0;
            border-radius: 10px;
            overflow: hidden;
            z-index: 999;
        }
        #statusFill {
            height: 100%;
            width: 100%;
            background: #0f0;
            transition: width 0.3s;
        }
        #statusLabel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #000;
            text-shadow: 0 0 5px #000;
        }

        /* Escape indicator */
        #escapeHint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 28px;
            color: #0f0;
            text-shadow: 0 0 20px #0f0;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 800;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="instructions">
        <h3>üïπÔ∏è Steuerung</h3>
        <ul>
            <li><span class="key">WASD</span> / <span class="key">Pfeile</span> Bewegen</li>
            <li><span class="key">üì±</span> Handy √∂ffnen</li>
            <li><span class="key">E</span> Item aufheben</li>
            <li><span class="key">1-4</span> Item benutzen</li>
        </ul>
        <div style="margin-top:8px; font-size:12px; color:#888;">
            Finde den <span style="color:#f00">üî¥ roten Ausgang</span> oder sammle alle <span style="color:#ff0">üìÑ Notizen</span>.
        </div>
    </div>

    <div id="statusBar">
        <div id="statusFill"></div>
        <div id="statusLabel">STATUS</div>
    </div>

    <div id="escapeHint">üî¥ ENTFESSEN! ZUM AUSGANG!</div>
    
    <div id="inventoryBar"></div>

    <div id="phoneIcon">üì±</div>
    
    <div id="phoneOverlay">
        <button id="closePhone">‚úï</button>
        <div id="phoneInterface">
            <div id="phoneHeader">Signal: ‚ö†Ô∏è Schwach</div>
            <div id="messageList"></div>
            <div id="inputArea">
                <input type="text" id="messageInput" placeholder="Antwort...">
                <button id="sendButton">SEND</button>
            </div>
        </div>
    </div>

    <script>
        // ================= CONFIG =================
        const TILE_SIZE = 40;
        const MAP_WIDTH = 50;
        const MAP_HEIGHT = 35;
        const PLAYER_SPEED = 4;

        // ================= STATE =================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const phoneIcon = document.getElementById('phoneIcon');
        const phoneOverlay = document.getElementById('phoneOverlay');
        const phoneInterface = document.getElementById('phoneInterface');
        const closePhone = document.getElementById('closePhone');
        const messageList = document.getElementById('messageList');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const inventoryBar = document.getElementById('inventoryBar');
        const statusFill = document.getElementById('statusFill');
        const escapeHint = document.getElementById('escapeHint');

        let phoneOpen = false;
        let messages = [];
        let gameOver = false;
        let escaped = false;
        let allNotesCollected = false;
        let escapeUnlocked = false;

        // Player
        const player = {
            x: TILE_SIZE * 3,
            y: TILE_SIZE * 3,
            width: 20,
            height: 20,
            speed: PLAYER_SPEED,
            invincible: false,
            speedBoost: 1
        };

        // Input
        const keys = {};

        // Map
        const walls = [];
        const floorTiles = [];
        const notes = [];
        const items = [];
        const exitDoor = { x: 0, y: 0, w: TILE_SIZE*2, h: TILE_SIZE*2 };

        // Generate map
        function generateMap() {
            // Create floor grid
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    floorTiles.push({ x: x * TILE_SIZE, y: y * TILE_SIZE, type: Math.random() > 0.3 ? 'floor' : 'carpet' });
                }
            }

            // Add outer walls
            for (let i = 0; i < MAP_WIDTH; i++) {
                walls.push({ x: i * TILE_SIZE, y: 0, w: TILE_SIZE, h: TILE_SIZE });
                walls.push({ x: i * TILE_SIZE, y: (MAP_HEIGHT-1) * TILE_SIZE, w: TILE_SIZE, h: TILE_SIZE });
            }
            for (let i = 0; i < MAP_HEIGHT; i++) {
                walls.push({ x: 0, y: i * TILE_SIZE, w: TILE_SIZE, h: TILE_SIZE });
                walls.push({ x: (MAP_WIDTH-1) * TILE_SIZE, y: i * TILE_SIZE, w: TILE_SIZE, h: TILE_SIZE });
            }

            // Internal random walls (rooms and corridors)
            for (let i = 0; i < 150; i++) {
                const wx = Math.floor(Math.random() * (MAP_WIDTH - 4)) + 2;
                const wy = Math.floor(Math.random() * (MAP_HEIGHT - 4)) + 2;
                const ww = Math.floor(Math.random() * 3) + 1;
                const wh = Math.floor(Math.random() * 3) + 1;
                for (let dx = 0; dx < ww; dx++) {
                    for (let dy = 0; dy < wh; dy++) {
                        walls.push({ x: (wx+dx)*TILE_SIZE, y: (wy+dy)*TILE_SIZE, w: TILE_SIZE, h: TILE_SIZE });
                    }
                }
            }

            // Ensure spawn area is clear (3x3 tiles around player)
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const sx = (3 + dx) * TILE_SIZE;
                    const sy = (3 + dy) * TILE_SIZE;
                    // Remove any wall at spawn location
                    for (let i = walls.length - 1; i >= 0; i--) {
                        if (walls[i].x === sx && walls[i].y === sy) {
                            walls.splice(i, 1);
                        }
                    }
                }
            }

            // Place exit door (red) in a far corner
            exitDoor.x = (MAP_WIDTH - 4) * TILE_SIZE;
            exitDoor.y = (MAP_HEIGHT - 4) * TILE_SIZE;

            // Place notes (5)
            for (let i = 0; i < 5; i++) {
                let placed = false;
                while (!placed) {
                    const tx = Math.floor(Math.random() * (MAP_WIDTH - 2)) + 1;
                    const ty = Math.floor(Math.random() * (MAP_HEIGHT - 2)) + 1;
                    if (!isWall(tx * TILE_SIZE, ty * TILE_SIZE) && distance(tx * TILE_SIZE + TILE_SIZE/2, ty * TILE_SIZE + TILE_SIZE/2, player.x, player.y) > 200) {
                        notes.push({
                            x: tx * TILE_SIZE + 5,
                            y: ty * TILE_SIZE + 5,
                            w: TILE_SIZE - 10,
                            h: TILE_SIZE - 10,
                            collected: false,
                            content: getNoteContent(i)
                        });
                        placed = true;
                    }
                }
            }

            // Place items (batteries, speed, invis)
            const itemTypes = [
                { type: 'battery', icon: 'üîã', name: 'Batterie' },
                { type: 'speed', icon: 'üíä', name: 'Speed' },
                { type: 'invis', icon: 'üëª', name: 'Unsichtbarkeit' },
                { type: 'key', icon: 'üîë', name: 'Schl√ºssel' }
            ];
            for (let i = 0; i < 12; i++) {
                const itype = itemTypes[i % itemTypes.length];
                let placed = false;
                while (!placed) {
                    const tx = Math.floor(Math.random() * (MAP_WIDTH - 2)) + 1;
                    const ty = Math.floor(Math.random() * (MAP_HEIGHT - 2)) + 1;
                    if (!isWall(tx * TILE_SIZE, ty * TILE_SIZE)) {
                        items.push({
                            x: tx * TILE_SIZE + 5,
                            y: ty * TILE_SIZE + 5,
                            w: TILE_SIZE - 10,
                            h: TILE_SIZE - 10,
                            ...itype,
                            count: 1
                        });
                        placed = true;
                    }
                }
            }
        }

        function getNoteContent(index) {
            const texts = [
                "Ich sehe dich. Du bist nicht wirklich hier.",
                "Das Spiegelbild l√ºgt. Vertraue ihm nicht.",
                "Die rote T√ºr ist der einzige Weg. Aber sie... beobachtet.",
                "Batterien halten das Handy am Leben. Ohne Licht bist du verloren.",
                "Ich war auch mal wie du. Dann wurde ich zum Spiegel."
            ];
            return texts[index];
        }

        // Utility
        function distance(x1, y1, x2, y2) {
            return Math.hypot(x2 - x1, y2 - y1);
        }

        function isWall(x, y) {
            return walls.some(w => x >= w.x && x < w.x + w.w && y >= w.y && y < w.y + w.h);
        }

        function rectCollide(a, b) {
            return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
        }

        // ================= DRAWING =================
        function drawBackground() {
            const camX = player.x - canvas.width / 2;
            const camY = player.y - canvas.height / 2;
            ctx.save();
            ctx.translate(-camX, -camY);

            // Floor
            for (let tile of floorTiles) {
                ctx.fillStyle = tile.type === 'floor' ? '#1a1a1a' : '#222';
                ctx.fillRect(tile.x, tile.y, TILE_SIZE, TILE_SIZE);
                ctx.strokeStyle = '#111';
                ctx.strokeRect(tile.x, tile.y, TILE_SIZE, TILE_SIZE);
            }

            // Walls
            ctx.fillStyle = '#333';
            for (let wall of walls) {
                ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
                ctx.strokeStyle = '#444';
                ctx.strokeRect(wall.x, wall.y, wall.w, wall.h);
            }

            // Exit door (initially locked)
            ctx.fillStyle = escapeUnlocked ? 'rgba(255,0,0,0.3)' : 'rgba(100,0,0,0.5)';
            ctx.fillRect(exitDoor.x, exitDoor.y, exitDoor.w, exitDoor.h);
            ctx.strokeStyle = escapeUnlocked ? '#f00' : '#600';
            ctx.lineWidth = 4;
            ctx.strokeRect(exitDoor.x, exitDoor.y, exitDoor.w, exitDoor.h);
            ctx.lineWidth = 1;
            if (escapeUnlocked) {
                ctx.fillStyle = '#f00';
                ctx.font = '20px monospace';
                ctx.fillText('ENTFESSEN!', exitDoor.x + 5, exitDoor.y + exitDoor.h/2 + 7);
            }

            // Notes
            for (let note of notes) {
                if (!note.collected) {
                    ctx.fillStyle = '#ff0';
                    ctx.fillRect(note.x, note.y, note.w, note.h);
                    ctx.fillStyle = '#000';
                    ctx.font = '20px monospace';
                    ctx.fillText('üìÑ', note.x + 8, note.y + 25);
                }
            }

            // Items
            for (let item of items) {
                if (item.count > 0) {
                    ctx.globalAlpha = 0.7 + Math.sin(Date.now() * 0.005) * 0.3;
                    ctx.fillStyle = '#0f0';
                    ctx.fillRect(item.x, item.y, item.w, item.h);
                    ctx.fillStyle = '#000';
                    ctx.font = '20px monospace';
                    ctx.fillText(item.icon, item.x + 10, item.y + 25);
                    ctx.globalAlpha = 1;
                }
            }

            // Player
            ctx.fillStyle = '#0f0';
            ctx.fillRect(player.x - player.width/2, player.y - player.height/2, player.width, player.height);
            ctx.fillStyle = player.invincible ? '#ff0' : '#000';
            ctx.fillRect(player.x - 4, player.y - 2, 3, 3);
            ctx.fillRect(player.x + 1, player.y - 2, 3, 3);

            ctx.restore();
        }

        // ================= GAME LOGIC =================
        function updatePlayer() {
            if (gameOver || escaped) return;

            let dx = 0, dy = 0;
            if (keys['w'] || keys['ArrowUp']) dy = -player.speed * player.speedBoost;
            if (keys['s'] || keys['ArrowDown']) dy = player.speed * player.speedBoost;
            if (keys['a'] || keys['ArrowLeft']) dx = -player.speed * player.speedBoost;
            if (keys['d'] || keys['ArrowRight']) dx = player.speed * player.speedBoost;

            const newX = player.x + dx;
            const newY = player.y + dy;

            const playerRect = { x: newX - player.width/2, y: newY - player.height/2, w: player.width, h: player.height };
            if (!walls.some(w => rectCollide(playerRect, w))) {
                player.x = newX;
                player.y = newY;
            }

            player.x = Math.max(TILE_SIZE, Math.min(player.x, MAP_WIDTH * TILE_SIZE - TILE_SIZE));
            player.y = Math.max(TILE_SIZE, Math.min(player.y, MAP_HEIGHT * TILE_SIZE - TILE_SIZE));
        }

        function updateStatus() {
            if (gameOver || escaped) return;
            
            // Simple status: show notes collected
            const collectedCount = notes.filter(n => n.collected).length;
            const totalCount = notes.length;
            statusFill.style.width = (collectedCount / totalCount * 100) + '%';
            document.getElementById('statusLabel').textContent = `Notizen: ${collectedCount}/${totalCount}`;

            // Check escape condition
            if (allNotesCollected && !escapeUnlocked) {
                escapeUnlocked = true;
                addMessage('System', 'Das Geheimnis ist gel√ºftet. Die rote T√ºr ist jetzt offen!', false);
            }

            // Show escape hint close to door
            const distToDoor = distance(player.x, player.y, exitDoor.x + exitDoor.w/2, exitDoor.y + exitDoor.h/2);
            if (escapeUnlocked && distToDoor < 150) {
                escapeHint.style.opacity = 1;
            } else {
                escapeHint.style.opacity = 0;
            }

            // Win condition
            if (escapeUnlocked && rectCollide(
                {x: player.x - player.width/2, y: player.y - player.height/2, w: player.width, h: player.height},
                exitDoor
            )) {
                escaped = true;
                addMessage('System', 'DU BIST ENTFLOHEN!', false);
                setTimeout(() => {
                    alert('Du bist entkommen! Gut gemacht!');
                    location.reload();
                }, 2000);
            }
        }

        function checkItemPickup() {
            if (gameOver || escaped) return;

            // Notes
            for (let note of notes) {
                if (!note.collected && rectCollide(
                    {x: player.x - player.width/2, y: player.y - player.height/2, w: player.width, h: player.height},
                    note
                )) {
                    note.collected = true;
                    addMessage('System', 'Notiz gefunden: "' + note.content + '"', false);
                    inventoryAdd('note', 'üìÑ');
                    if (notes.every(n => n.collected)) {
                        allNotesCollected = true;
                        addMessage('System', 'Alle Notizen gesammelt! Nun gibt es einen Weg...', false);
                    }
                }
            }

            // Items
            for (let item of items) {
                if (item.count > 0 && rectCollide(
                    {x: player.x - player.width/2, y: player.y - player.height/2, w: player.width, h: player.height},
                    item
                )) {
                    item.count = 0;
                    inventoryAdd(item.type, item.icon);
                    addMessage('System', item.name + ' aufgenommen!', false);
                }
            }
        }

        // ================= INVENTORY =================
        const inventory = {};

        function inventoryAdd(type, icon) {
            if (!inventory[type]) inventory[type] = { count: 0, icon };
            inventory[type].count++;
            renderInventoryBar();
        }

        function inventoryUse(type) {
            if (!inventory[type] || inventory[type].count <= 0) return;
            
            inventory[type].count--;
            if (inventory[type].count <= 0) delete inventory[type];

            if (type === 'battery') {
                addMessage('System', 'Batterie gesammelt. Das Handy h√§lt l√§nger.', false);
            } else if (type === 'speed') {
                player.speedBoost = 2;
                setTimeout(() => player.speedBoost = 1, 10000);
                addMessage('System', 'Speed aktiv! 10s doppelte Geschwindigkeit.', false);
            } else if (type === 'invis') {
                player.invincible = true;
                setTimeout(() => player.invincible = false, 8000);
                addMessage('System', 'Unsichtbarkeit! 8s lang sicher.', false);
            } else if (type === 'key') {
                escapeUnlocked = true;
                addMessage('System', 'Schl√ºssel benutzt. Die rote T√ºr ist offen!', false);
            }

            renderInventoryBar();
        }

        function renderInventoryBar() {
            inventoryBar.innerHTML = '';
            const types = ['note', 'battery', 'speed', 'invis', 'key'];
            for (let type of types) {
                if (inventory[type]) {
                    const slot = document.createElement('div');
                    slot.className = 'invSlot';
                    slot.innerHTML = inventory[type].icon + `<span class="count">${inventory[type].count}</span>`;
                    slot.onclick = () => inventoryUse(type);
                    inventoryBar.appendChild(slot);
                }
            }
        }

        // ================= PHONE LOGIC =================
        function addMessage(sender, text, isSent = false) {
            const msgDiv = document.createElement('div');
            msgDiv.className = 'message ' + (isSent ? 'sent' : 'received');
            msgDiv.innerHTML = `
                <div class="sender">${sender}</div>
                <div class="text">${text}</div>
            `;
            messageList.appendChild(msgDiv);
            messageList.scrollTop = messageList.scrollHeight;
        }

        function showPhone() {
            phoneOverlay.style.display = 'flex';
            phoneOpen = true;
            if (!phoneInitialized) {
                phoneInitialized = true;
                startPhoneStory();
            }
        }

        function hidePhone() {
            phoneOverlay.style.display = 'none';
            phoneOpen = false;
        }

        phoneIcon.addEventListener('click', showPhone);
        closePhone.addEventListener('click', hidePhone);

        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        function sendMessage() {
            const text = messageInput.value.trim();
            if (text) {
                addMessage('Ich', text, true);
                messageInput.value = '';
                handlePhoneChoice(text.toLowerCase());
            }
        }

        let phoneInitialized = false;
        let storyState = 0;

        function startPhoneStory() {
            addMessage('System', 'Signal gefunden. Verbindung instabil.', false);
            setTimeout(() => {
                addMessage('???', 'Hallo? Bist du das?', false);
            }, 2000);
            setTimeout(() => {
                addMessage('Unbekannt', 'Ich bin... du. Aus einer anderen Zeit. Du musst hier raus.', false);
            }, 6000);
            setTimeout(() => {
                addMessage('System', 'Antworte mit JA oder NEIN.', false);
            }, 8000);
        }

        function handlePhoneChoice(choice) {
            if (storyState === 0) {
                if (choice.includes('ja')) {
                    addMessage('Ich', 'Ja, ich bin es.', true);
                    addMessage('Spiegel', 'Gut. Dann wei√üt du, was du tun musst. Finde die f√ºnf Notizen. Sie sagen dir, wie du die T√ºr √∂ffnest.', false);
                    storyState = 1;
                } else if (choice.includes('nein')) {
                    addMessage('Ich', 'Nein, wer bist du?', true);
                    addMessage('Spiegel', 'L√ºgner. Du bist hier. Und du wirst sterben, wenn du nicht handelst.', false);
                    storyState = 2;
                } else {
                    addMessage('Spiegel', 'Ich verstehe. Aber Zeit rennt.', false);
                }
            } else if (storyState === 1) {
                addMessage('Spiegel', 'Ich warte auf dich. Im Spiegel.', false);
                storyState = 3;
            } else if (storyState === 2) {
                addMessage('Spiegel', 'Dann beweis es. √úberlebe.', false);
                storyState = 3;
            }
        }

        // ================= INPUT HANDLING =================
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if ((e.key === 'r' || e.key === 'R') && gameOver) {
                location.reload();
            }
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // ================= MAIN LOOP =================
        function gameLoop() {
            if (!gameOver && !escaped) {
                updatePlayer();
                updateStatus();
                checkItemPickup();
            }
            drawBackground();
            requestAnimationFrame(gameLoop);
        }

        // ================= INIT =================
        generateMap();
        gameLoop();
        renderInventoryBar();

        console.log('Spiel geladen! Viel Spa√ü, Leo! ü¶éüéÆ');
    </script>
</body>
</html>