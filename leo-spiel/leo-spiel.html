<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flucht im Dunkeln</title>
    <style>
        * { margin: 0; padding: 0; }
        body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 15px; left: 15px;
            color: #ff3333; font-size: 18px;
            text-shadow: 0 0 10px #ff0000;
            pointer-events: none; z-index: 10;
        }
        #timer {
            position: absolute; top: 15px; right: 15px;
            color: #888; font-size: 16px;
            pointer-events: none; z-index: 10;
        }
        /* abilities removed */
        #message {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000; font-size: 36px; text-align: center;
            text-shadow: 0 0 30px currentColor;
            display: none; pointer-events: none; z-index: 20;
            transition: opacity 0.5s;
        }
        #toast {
            position: absolute; top: 75px; left: 50%;
            transform: translateX(-50%);
            color: #ff6600; font-size: 20px; text-align: center;
            text-shadow: 0 0 15px currentColor;
            opacity: 0; pointer-events: none; z-index: 15;
            transition: opacity 0.3s;
        }
        #instructions {
            position: absolute; bottom: 15px; left: 15px;
            color: #555; font-size: 13px;
            pointer-events: none; z-index: 10;
        }
        #startscreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 50;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            color: #ff3333; text-align: center;
        }
        #startscreen h1 {
            font-size: 48px; text-shadow: 0 0 40px #ff0000;
            margin-bottom: 20px; animation: flicker 3s infinite;
        }
        #startscreen p { color: #888; font-size: 16px; margin: 8px 0; max-width: 500px; }
        #startscreen .start-btn {
            margin-top: 30px; padding: 15px 40px;
            background: none; border: 2px solid #ff3333;
            color: #ff3333; font-family: inherit; font-size: 20px;
            cursor: pointer; transition: all 0.3s;
        }
        #startscreen .start-btn:hover {
            background: #ff3333; color: #000;
            box-shadow: 0 0 30px #ff0000;
        }
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            92% { opacity: 1; }
            93% { opacity: 0.3; }
            94% { opacity: 1; }
            96% { opacity: 0.5; }
            97% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="startscreen">
        <h1>üî¶ FLUCHT IM DUNKELN</h1>
        <p style="color:#aaa; font-style:italic;">Ein Engel ist gefallen.</p>
        <p>Einst ein W√§chter des Himmels ‚Äî jetzt wandert er durch die Dunkelheit, getrieben von unstillbarem <span style="color:#ff0000">Blutdurst</span>.</p>
        <p>Er jagt Menschen. Aber er ist... <span style="color:#ff4444">fair</span>.</p>
        <p style="color:#aaa;">Jetzt ist er bekannt als der <span style="color:#ff0000; font-size:20px; text-shadow: 0 0 15px #ff0000;">CELESTIAL</span>.</p>
        <p style="color:#ccc; margin-top:10px;">Sammle f√ºr ihn alle Blutspuren, w√§hrend er dich jagt ‚Äî und er l√§sst dich am Leben.</p>
        <p style="color:#ff6600; margin-top:15px;">‚ö†Ô∏è Vorsicht: Manche Spuren sind <span style="color:#00cc00">FAKE</span>! Sie kosten dich Punkte.</p>
        <p style="color:#555; margin-top:15px; font-size:13px;">
            WASD / Pfeiltasten = Bewegen<br>
            R = Neustart
        </p>
        <button class="start-btn" onclick="startGame()">‚ñ∂ SPIELEN</button>
    </div>
    <div id="ui">Spuren: <span id="score">0</span> / <span id="total">0</span></div>
    <div id="timer">Zeit: 0s</div>
    <!-- abilities removed -->
    <div id="message"></div>
    <div id="toast"></div>
    <div id="instructions">WASD / Pfeile ‚Ä¢ R = Neustart</div>
    <canvas id="game"></canvas>

    <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });

    // ‚îÄ‚îÄ‚îÄ GAME STATE ‚îÄ‚îÄ‚îÄ
    const G = {
        player: { x: 0, y: 0, speed: 3.2, angle: 0 },
        tracks: [],
        monster: { x: 0, y: 0, speed: 0.7 },
        particles: [],
        shakeX: 0, shakeY: 0, shakeDur: 0,
        // Abilities
        teleportTimer: 0, teleportCooldown: 8000, teleportFlash: 0,
        lightsOutTimer: 0, lightsOutPhase: 'none', lightsOutStart: 0,
        darkPulseTimer: 0, darkPulseActive: false,
        // Game
        startTime: 0, found: 0, total: 0,
        gameOver: false, won: false, started: false,
        flashRadius: 260, flashCone: Math.PI / 3.8,
        // Toast
        toastTimer: 0
    };

    // ‚îÄ‚îÄ‚îÄ AUDIO ‚îÄ‚îÄ‚îÄ
    let audioCtx = null, masterGain = null, organGain = null, heartGain = null;
    let audioStarted = false, organInterval = null, heartInterval = null;

    function initAudio() {
        if (audioStarted) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.5;
        masterGain.connect(audioCtx.destination);

        // Organ channel
        organGain = audioCtx.createGain();
        organGain.gain.value = 0.08;
        organGain.connect(masterGain);

        // Heartbeat channel
        heartGain = audioCtx.createGain();
        heartGain.gain.value = 0;
        heartGain.connect(masterGain);

        audioStarted = true;
        startOrgan();
    }

    // üéµ Eerie Organ - leise im Hintergrund
    function playOrganNote(freq, dur) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        // Organ = layered oscillators through low-pass
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        filter.Q.value = 2;

        g.gain.setValueAtTime(0, audioCtx.currentTime);
        g.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.3);
        g.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + dur * 0.6);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);

        osc.connect(filter);
        filter.connect(g);
        g.connect(organGain);
        osc.start();
        osc.stop(audioCtx.currentTime + dur);

        // Add subtle second voice (fifth above)
        const osc2 = audioCtx.createOscillator();
        const g2 = audioCtx.createGain();
        osc2.type = 'sine';
        osc2.frequency.value = freq * 1.5;
        g2.gain.setValueAtTime(0, audioCtx.currentTime);
        g2.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime + 0.5);
        g2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
        osc2.connect(g2);
        g2.connect(organGain);
        osc2.start();
        osc2.stop(audioCtx.currentTime + dur);
    }

    const organNotes = [55, 58.27, 65.41, 73.42, 82.41, 87.31, 98, 110];
    function startOrgan() {
        if (organInterval) return;
        function playNext() {
            if (!G.started || G.gameOver) return;
            const note = organNotes[Math.floor(Math.random() * organNotes.length)];
            const dur = 2 + Math.random() * 4;
            playOrganNote(note, dur);
            organInterval = setTimeout(playNext, (2000 + Math.random() * 3000));
        }
        playNext();
    }

    function stopOrgan() {
        if (organInterval) { clearTimeout(organInterval); organInterval = null; }
    }

    // üíì Herzschlag-Echo f√ºr Dark Pulse
    function playHeartbeat() {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;

        // "Lub" - tiefer Schlag
        const osc1 = audioCtx.createOscillator();
        const g1 = audioCtx.createGain();
        osc1.type = 'sine';
        osc1.frequency.setValueAtTime(60, now);
        osc1.frequency.exponentialRampToValueAtTime(30, now + 0.15);
        g1.gain.setValueAtTime(0.6, now);
        g1.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        osc1.connect(g1);
        g1.connect(heartGain);
        osc1.start(now);
        osc1.stop(now + 0.25);

        // "Dub" - zweiter Schlag
        const osc2 = audioCtx.createOscillator();
        const g2 = audioCtx.createGain();
        osc2.type = 'sine';
        osc2.frequency.setValueAtTime(50, now + 0.15);
        osc2.frequency.exponentialRampToValueAtTime(25, now + 0.3);
        g2.gain.setValueAtTime(0, now);
        g2.gain.setValueAtTime(0.4, now + 0.15);
        g2.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
        osc2.connect(g2);
        g2.connect(heartGain);
        osc2.start(now);
        osc2.stop(now + 0.45);

        // Echo (delayed, quieter)
        const osc3 = audioCtx.createOscillator();
        const g3 = audioCtx.createGain();
        osc3.type = 'sine';
        osc3.frequency.setValueAtTime(45, now + 0.5);
        osc3.frequency.exponentialRampToValueAtTime(20, now + 0.7);
        g3.gain.setValueAtTime(0.15, now + 0.5);
        g3.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
        osc3.connect(g3);
        g3.connect(heartGain);
        osc3.start(now + 0.5);
        osc3.stop(now + 0.85);
    }

    function startHeartbeat() {
        if (heartInterval) return;
        heartGain.gain.linearRampToValueAtTime(0.6, audioCtx.currentTime + 0.3);
        playHeartbeat();
        heartInterval = setInterval(playHeartbeat, 900);
    }

    function stopHeartbeat() {
        if (heartInterval) { clearInterval(heartInterval); heartInterval = null; }
        if (heartGain) heartGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
    }

    // Audio mit User-Interaktion starten
    function tryInitAudio() { initAudio(); }

    // ‚îÄ‚îÄ‚îÄ PARTICLES ‚îÄ‚îÄ‚îÄ
    function spawnParticles(x, y, color, count = 8) {
        for (let i = 0; i < count; i++) {
            const a = Math.random() * Math.PI * 2;
            const spd = 1 + Math.random() * 3;
            G.particles.push({
                x, y, vx: Math.cos(a) * spd, vy: Math.sin(a) * spd,
                life: 1, decay: 0.02 + Math.random() * 0.03,
                size: 2 + Math.random() * 4, color
            });
        }
    }

    function updateParticles() {
        for (let i = G.particles.length - 1; i >= 0; i--) {
            const p = G.particles[i];
            p.x += p.vx; p.y += p.vy;
            p.life -= p.decay;
            if (p.life <= 0) G.particles.splice(i, 1);
        }
    }

    function renderParticles() {
        G.particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;
    }

    // ‚îÄ‚îÄ‚îÄ SCREEN SHAKE ‚îÄ‚îÄ‚îÄ
    function shake(intensity = 5, duration = 200) {
        G.shakeDur = duration;
        G.shakeIntensity = intensity;
    }

    // ‚îÄ‚îÄ‚îÄ TOAST (temporary message) ‚îÄ‚îÄ‚îÄ
    function showToast(text, color = '#ff6600', duration = 1500) {
        const el = document.getElementById('toast');
        el.innerHTML = text;
        el.style.color = color;
        el.style.textShadow = `0 0 15px ${color}`;
        el.style.opacity = 1;
        G.toastTimer = duration;
    }

    function showMessage(text, color = '#ff0000') {
        const el = document.getElementById('message');
        el.innerHTML = text;
        el.style.color = color;
        el.style.textShadow = `0 0 30px ${color}`;
        el.style.display = 'block';
        el.style.opacity = 1;
    }

    // ‚îÄ‚îÄ‚îÄ INIT ‚îÄ‚îÄ‚îÄ
    function init() {
        G.found = 0;
        G.gameOver = false;
        G.won = false;
        G.particles = [];
        G.shakeDur = 0;
        G.toastTimer = 0;

        const now = Date.now();
        G.teleportTimer = now;
        G.teleportFlash = 0;
        G.lightsOutTimer = now;
        G.lightsOutPhase = 'none';
        G.darkPulseTimer = now;
        G.darkPulseActive = false;
        G.startTime = now;

        // Player center
        G.player.x = canvas.width / 2;
        G.player.y = canvas.height / 2;
        G.player.angle = 0;

        // Spawn real tracks (9-12) in clusters
        G.tracks = [];
        const total = 14 + Math.floor(Math.random() * 5);
        let created = 0;

        while (created < total) {
            const cx = 80 + Math.random() * (canvas.width - 160);
            const cy = 80 + Math.random() * (canvas.height - 160);
            if (Math.hypot(cx - G.player.x, cy - G.player.y) < 180) continue;

            const cluster = Math.random() < 0.6 ? (Math.random() < 0.5 ? 2 : 3) : 1;
            const actual = Math.min(cluster, total - created);

            for (let i = 0; i < actual; i++) {
                const a = Math.random() * Math.PI * 2;
                const d = i === 0 ? 0 : 20 + Math.random() * 35;
                const sizeMul = [0.6, 1, 1, 1.3][Math.floor(Math.random() * 4)];
                G.tracks.push({
                    x: cx + Math.cos(a) * d,
                    y: cy + Math.sin(a) * d,
                    size: (12 + Math.random() * 18) * sizeMul,
                    shade: Math.random(), // 0=dark, 1=bright
                    isFake: false,
                    found: false
                });
                created++;
            }
        }
        G.total = created;

        // Fake tracks from monster (3-5)
        const fakes = 3 + Math.floor(Math.random() * 3);
        for (let i = 0; i < fakes; i++) {
            let fx, fy;
            do {
                fx = 60 + Math.random() * (canvas.width - 120);
                fy = 60 + Math.random() * (canvas.height - 120);
            } while (Math.hypot(fx - G.player.x, fy - G.player.y) < 150);
            G.tracks.push({
                x: fx, y: fy,
                size: 10 + Math.random() * 16,
                shade: Math.random(),
                isFake: true,
                found: false
            });
        }

        // Monster far from player
        do {
            G.monster.x = Math.random() * canvas.width;
            G.monster.y = Math.random() * canvas.height;
        } while (Math.hypot(G.monster.x - G.player.x, G.monster.y - G.player.y) < 400);

        document.getElementById('score').textContent = '0';
        document.getElementById('total').textContent = G.total;
        document.getElementById('message').style.display = 'none';
        document.getElementById('toast').style.opacity = 0;
        if (audioStarted) { stopHeartbeat(); startOrgan(); }
    }

    // ‚îÄ‚îÄ‚îÄ INPUT ‚îÄ‚îÄ‚îÄ
    const keys = {};
    document.addEventListener('keydown', e => {
        keys[e.key.toLowerCase()] = true;
        if (e.key.toLowerCase() === 'r' && G.gameOver) init();
    });
    document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    // ‚îÄ‚îÄ‚îÄ UPDATE ‚îÄ‚îÄ‚îÄ
    function update(dt) {
        if (G.gameOver) return;
        const now = Date.now();

        // Toast fade
        if (G.toastTimer > 0) {
            G.toastTimer -= dt;
            if (G.toastTimer <= 0) {
                document.getElementById('toast').style.opacity = 0;
            }
        }

        // Screen shake
        if (G.shakeDur > 0) {
            G.shakeDur -= dt;
            G.shakeX = (Math.random() - 0.5) * G.shakeIntensity * 2;
            G.shakeY = (Math.random() - 0.5) * G.shakeIntensity * 2;
        } else {
            G.shakeX = 0; G.shakeY = 0;
        }

        // Player movement
        let dx = 0, dy = 0;
        if (keys['w'] || keys['arrowup']) dy = -1;
        if (keys['s'] || keys['arrowdown']) dy = 1;
        if (keys['a'] || keys['arrowleft']) dx = -1;
        if (keys['d'] || keys['arrowright']) dx = 1;

        const speedMod = G.darkPulseActive ? 0.65 : 1;
        if (dx !== 0 || dy !== 0) {
            const len = Math.hypot(dx, dy);
            dx /= len; dy /= len;
            G.player.x = Math.max(15, Math.min(canvas.width - 15, G.player.x + dx * G.player.speed * speedMod));
            G.player.y = Math.max(15, Math.min(canvas.height - 15, G.player.y + dy * G.player.speed * speedMod));
            G.player.angle = Math.atan2(dy, dx);
        }

        // Monster chase
        const mx = G.player.x - G.monster.x;
        const my = G.player.y - G.monster.y;
        const md = Math.hypot(mx, my);
        const monsterMod = G.darkPulseActive ? 2.0 : 1;
        if (md > 0) {
            G.monster.x += (mx / md) * G.monster.speed * monsterMod;
            G.monster.y += (my / md) * G.monster.speed * monsterMod;
        }

        // ‚îÄ‚îÄ ABILITY: Divine Prediction (teleport in front of player every 8s) ‚îÄ‚îÄ
        if (now - G.teleportTimer > G.teleportCooldown) {
            const dist = G.flashRadius * 0.8;
            G.monster.x = Math.max(30, Math.min(canvas.width - 30,
                G.player.x + Math.cos(G.player.angle) * dist));
            G.monster.y = Math.max(30, Math.min(canvas.height - 30,
                G.player.y + Math.sin(G.player.angle) * dist));
            G.teleportTimer = now;
            G.teleportFlash = 800;
        }
        if (G.teleportFlash > 0) G.teleportFlash -= dt;

        // ‚îÄ‚îÄ ABILITY: Lights Out (every 13s: 3s flicker + 2s dark) ‚îÄ‚îÄ
        if (G.lightsOutPhase === 'none' && now - G.lightsOutTimer > 13000) {
            G.lightsOutPhase = 'flicker';
            G.lightsOutStart = now;
        }
        if (G.lightsOutPhase === 'flicker' && now - G.lightsOutStart > 3000) {
            G.lightsOutPhase = 'dark';
            G.lightsOutStart = now;
            shake(4, 500);
        }
        if (G.lightsOutPhase === 'dark' && now - G.lightsOutStart > 2000) {
            G.lightsOutPhase = 'none';
            G.lightsOutTimer = now;
        }

        // ‚îÄ‚îÄ ABILITY: Dark Pulse Realm (every 20s for 4s) ‚îÄ‚îÄ
        if (!G.darkPulseActive && now - G.darkPulseTimer > 20000) {
            G.darkPulseActive = true;
            G.darkPulseTimer = now;
            shake(6, 400);
            startHeartbeat();
        }
        if (G.darkPulseActive && now - G.darkPulseTimer > 4000) {
            G.darkPulseActive = false;
            G.darkPulseTimer = now;
            stopHeartbeat();
        }

        // Catch player
        if (md < 28) {
            G.gameOver = true;
            G.won = false;
            shake(15, 500);
            stopOrgan(); stopHeartbeat();
            showMessage('üíÄ DU WURDEST ERWISCHT!<br><small>R = Neustart</small>');
        }

        // Collect tracks
        G.tracks.forEach(track => {
            if (track.found) return;
            const d = Math.hypot(track.x - G.player.x, track.y - G.player.y);
            if (d > 35) return;

            // Must be in flashlight cone
            const a = Math.atan2(track.y - G.player.y, track.x - G.player.x);
            let diff = a - G.player.angle;
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            if (Math.abs(diff) > G.flashCone / 2) return;

            track.found = true;

            if (track.isFake) {
                // Fake! Subtract point + warning
                G.found = Math.max(0, G.found - 1);
                shake(6, 250);
                spawnParticles(track.x, track.y, '#00ff00', 12);
                showToast('‚ö†Ô∏è FALSCHE SPUR! -1', '#ff6600', 1500);
            } else {
                // Real track
                G.found++;
                spawnParticles(track.x, track.y, '#ff0000', 10);

                if (G.found >= G.total) {
                    G.gameOver = true;
                    G.won = true;
                    const secs = Math.floor((Date.now() - G.startTime) / 1000);
                    stopOrgan(); stopHeartbeat();
                    showMessage(`üèÜ ENTKOMMEN!<br><small>${secs}s ‚Äî R = Neustart</small>`, '#00ff00');
                }
            }
            document.getElementById('score').textContent = G.found;
        });

        updateParticles();
    }

    // ‚îÄ‚îÄ‚îÄ RENDER ‚îÄ‚îÄ‚îÄ
    function render() {
        ctx.save();
        ctx.translate(G.shakeX, G.shakeY);

        // Clear
        ctx.fillStyle = '#050505';
        ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);

        // ‚îÄ‚îÄ Draw blood tracks ‚îÄ‚îÄ
        G.tracks.forEach(track => {
            if (track.found) return;
            const d = Math.hypot(track.x - G.player.x, track.y - G.player.y);
            if (d > G.flashRadius) return;

            const s = track.shade;
            const r = Math.floor(100 + s * 120);
            const g = Math.floor(20 + s * 20);
            const b = Math.floor(20 + s * 15);
            const alpha = (1 - d / G.flashRadius) * (0.5 + s * 0.5);

            // Blood puddle - runder aber leicht unregelm√§√üig
            ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
            ctx.beginPath();
            const steps = 12;
            for (let i = 0; i < steps; i++) {
                const angle = (i / steps) * Math.PI * 2;
                const wobble = 0.85 + Math.sin(i * 1.8 + track.x * 0.1) * 0.15;
                const px = track.x + Math.cos(angle) * track.size * wobble;
                const py = track.y + Math.sin(angle) * track.size * wobble;
                i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();

            // Fake tracks: gr√ºne Umrandung
            if (track.isFake) {
                ctx.strokeStyle = `rgba(0, 200, 0, ${alpha * 0.7})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        });

        // ‚îÄ‚îÄ Draw monster (Celestial) ‚îÄ‚îÄ
        const t = Date.now() / 1000;
        const mx = G.monster.x, my = G.monster.y;

        // Wings (dark, barely visible)
        ctx.fillStyle = '#080808';
        ctx.strokeStyle = '#151515';
        ctx.lineWidth = 1.5;
        for (let i = 0; i < 4; i++) {
            const flap = Math.sin(t * 3 + i * 0.5) * (10 + i * 3);
            const lwx = mx - 38 - flap, lwy = my - 18 + i * 22;
            const rwx = mx + 38 + flap, rwy = my - 18 + i * 22;
            ctx.beginPath();
            ctx.ellipse(lwx, lwy, 28, 10, -0.2, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(rwx, rwy, 28, 10, 0.2, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();

            // üëÅÔ∏è 4 Augen pro Fl√ºgel, am oberen Rand
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 10;
            for (let e = 0; e < 4; e++) {
                const eyeOffset = -20 + e * 13;
                const eyeGlow = 0.4 + Math.sin(t * 3 + i * 1.5 + e * 0.8) * 0.4;
                const eyeSize = 1.8 + Math.sin(t * 2 + e) * 0.4;
                ctx.fillStyle = `rgba(255, 255, 255, ${eyeGlow})`;
                // Linker Fl√ºgel - Augen oben
                ctx.beginPath();
                ctx.arc(lwx + eyeOffset, lwy - 6, eyeSize, 0, Math.PI * 2);
                ctx.fill();
                // Rechter Fl√ºgel - Augen oben
                ctx.beginPath();
                ctx.arc(rwx + eyeOffset, rwy - 6, eyeSize, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#080808';
        }

        // Face wings
        ctx.fillStyle = '#060606';
        const fw = Math.sin(t * 2.5) * 7;
        ctx.beginPath();
        ctx.ellipse(mx - 18, my - 8, 16, 20, -0.3, 0, Math.PI * 2);
        ctx.fill(); ctx.stroke();
        ctx.beginPath();
        ctx.ellipse(mx + 18, my - 8, 16, 20, 0.3, 0, Math.PI * 2);
        ctx.fill(); ctx.stroke();

        // Body
        const wb = Math.sin(t * 3) * 2;
        ctx.beginPath();
        ctx.ellipse(mx, my + 18, 14 + wb, 16 - wb, 0, 0, Math.PI * 2);
        ctx.fillStyle = '#040404';
        ctx.fill(); ctx.stroke();

        // Halo
        ctx.beginPath();
        ctx.arc(mx, my - 42, 11, 0, Math.PI * 2);
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 2.5;
        ctx.stroke();

        // Eyes (red, always visible ‚Äî the scary part)
        const ea = Math.atan2(G.player.y - my, G.player.x - mx);
        const eyeGlow = 0.6 + Math.sin(t * 4) * 0.4;
        ctx.fillStyle = `rgba(255, 255, 255, ${eyeGlow})`;
        ctx.shadowColor = '#ffffff';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(mx + Math.cos(ea + 0.2) * 5, my + Math.sin(ea + 0.2) * 5 - 4, 3.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(mx + Math.cos(ea - 0.2) * 5, my + Math.sin(ea - 0.2) * 5 - 4, 3.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // ‚îÄ‚îÄ Flashlight / darkness mask ‚îÄ‚îÄ
        let lightR = G.flashRadius;
        let flicker = 1;

        if (G.lightsOutPhase === 'flicker') {
            flicker = 0.2 + Math.random() * 0.8;
            lightR = G.flashRadius * (0.4 + Math.random() * 0.6);
        } else if (G.lightsOutPhase === 'dark') {
            flicker = 0;
        }

        if (flicker > 0) {
            // Flashlight cone mask
            ctx.save();
            ctx.globalCompositeOperation = 'destination-in';
            ctx.beginPath();
            ctx.moveTo(G.player.x, G.player.y);
            ctx.arc(G.player.x, G.player.y, lightR,
                G.player.angle - G.flashCone / 2,
                G.player.angle + G.flashCone / 2);
            ctx.closePath();
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.restore();

            // Flashlight glow
            ctx.save();
            ctx.globalAlpha = 0.12 * flicker;
            ctx.beginPath();
            ctx.moveTo(G.player.x, G.player.y);
            ctx.arc(G.player.x, G.player.y, lightR,
                G.player.angle - G.flashCone / 2,
                G.player.angle + G.flashCone / 2);
            ctx.closePath();
            ctx.fillStyle = '#ffff88';
            ctx.fill();
            ctx.restore();
        } else {
            // Total darkness ‚Äî only tiny glow around player
            ctx.save();
            ctx.globalCompositeOperation = 'destination-in';
            ctx.beginPath();
            ctx.arc(G.player.x, G.player.y, 3, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.restore();
        }

        // ‚îÄ‚îÄ Player (always visible) ‚îÄ‚îÄ
        ctx.globalCompositeOperation = 'source-over';
        ctx.beginPath();
        ctx.arc(G.player.x, G.player.y, 11, 0, Math.PI * 2);
        ctx.fillStyle = '#ffcc99';
        ctx.fill();
        ctx.strokeStyle = '#c49070';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Small glow around player
        const pglow = ctx.createRadialGradient(G.player.x, G.player.y, 0, G.player.x, G.player.y, 30);
        pglow.addColorStop(0, 'rgba(255,200,150,0.08)');
        pglow.addColorStop(1, 'transparent');
        ctx.fillStyle = pglow;
        ctx.fillRect(G.player.x - 30, G.player.y - 30, 60, 60);

        // ‚îÄ‚îÄ Particles ‚îÄ‚îÄ
        renderParticles();

        // ‚îÄ‚îÄ Edge effects ‚îÄ‚îÄ
        const distM = Math.hypot(G.monster.x - G.player.x, G.monster.y - G.player.y);
        let danger = 0;
        if (distM < 200 && !G.gameOver) danger = Math.max(danger, (1 - distM / 200) * 0.5);
        if (G.teleportFlash > 0) danger = Math.max(danger, (G.teleportFlash / 800) * 0.7);

        // Dark Pulse Realm - intensivere Effekte
        if (G.darkPulseActive) {
            // Lila Overlay
            ctx.fillStyle = 'rgba(60, 0, 80, 0.4)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Pulsierende R√§nder
            const pulseI = 0.3 + Math.sin(Date.now() / 200) * 0.2;
            const dpg = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, canvas.height * 0.15,
                canvas.width / 2, canvas.height / 2, canvas.height * 0.6);
            dpg.addColorStop(0, 'transparent');
            dpg.addColorStop(1, `rgba(100, 0, 150, ${pulseI})`);
            ctx.fillStyle = dpg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Flackernde Partikel am Rand
            if (Math.random() < 0.3) {
                const side = Math.random() * 4 | 0;
                const px = side < 2 ? Math.random() * canvas.width : (side === 2 ? 0 : canvas.width);
                const py = side >= 2 ? Math.random() * canvas.height : (side === 0 ? 0 : canvas.height);
                spawnParticles(px, py, '#8800ff', 2);
            }
            
            // Taschenlampe flackert leicht
            G.flashRadius = 260 - Math.random() * 40;
        } else {
            G.flashRadius = 260;
        }

        // Red danger vignette
        if (danger > 0) {
            const vg = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, canvas.height * 0.25,
                canvas.width / 2, canvas.height / 2, canvas.height * 0.75);
            vg.addColorStop(0, 'transparent');
            vg.addColorStop(1, `rgba(255,0,0,${danger})`);
            ctx.fillStyle = vg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        ctx.restore(); // end shake

        // ‚îÄ‚îÄ HUD updates ‚îÄ‚îÄ
        const elapsed = Math.floor((Date.now() - G.startTime) / 1000);
        document.getElementById('timer').textContent = `Zeit: ${elapsed}s`;

        // abilities removed
    }

    // ‚îÄ‚îÄ‚îÄ GAME LOOP ‚îÄ‚îÄ‚îÄ
    let lastTime = 0;
    function loop(time) {
        const dt = Math.min(time - lastTime, 50); // cap at 50ms
        lastTime = time;
        if (G.started) {
            update(dt);
            render();
        }
        requestAnimationFrame(loop);
    }

    function startGame() {
        document.getElementById('startscreen').style.display = 'none';
        G.started = true;
        initAudio();
        init();
    }

    requestAnimationFrame(loop);
    </script>
</body>
</html>
